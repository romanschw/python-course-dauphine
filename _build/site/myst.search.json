{"version":"1","records":[{"hierarchy":{"lvl1":"Introduction à Python"},"type":"lvl1","url":"/","position":0},{"hierarchy":{"lvl1":"Introduction à Python"},"content":"This repository contains the course materials for the Applied Python undergraduate course, built with MyST.","type":"content","url":"/","position":1},{"hierarchy":{"lvl1":"Introduction à Python","lvl2":"Building the Website Locally"},"type":"lvl2","url":"/#building-the-website-locally","position":2},{"hierarchy":{"lvl1":"Introduction à Python","lvl2":"Building the Website Locally"},"content":"","type":"content","url":"/#building-the-website-locally","position":3},{"hierarchy":{"lvl1":"Introduction à Python","lvl3":"Prerequisites","lvl2":"Building the Website Locally"},"type":"lvl3","url":"/#prerequisites","position":4},{"hierarchy":{"lvl1":"Introduction à Python","lvl3":"Prerequisites","lvl2":"Building the Website Locally"},"content":"Node.js (v18 or higher)\n\nnpm or yarn","type":"content","url":"/#prerequisites","position":5},{"hierarchy":{"lvl1":"Introduction à Python","lvl3":"Installation","lvl2":"Building the Website Locally"},"type":"lvl3","url":"/#installation","position":6},{"hierarchy":{"lvl1":"Introduction à Python","lvl3":"Installation","lvl2":"Building the Website Locally"},"content":"Install MyST CLI globally:npm install -g mystmd\n\nInstall Python dependencies (optional, for Jupyter notebook support):pip install -r requirements.txt","type":"content","url":"/#installation","position":7},{"hierarchy":{"lvl1":"Introduction à Python","lvl3":"Build and Preview","lvl2":"Building the Website Locally"},"type":"lvl3","url":"/#build-and-preview","position":8},{"hierarchy":{"lvl1":"Introduction à Python","lvl3":"Build and Preview","lvl2":"Building the Website Locally"},"content":"Build the website:myst build\n\nStart a local development server:myst start\n\nThe website will be available at http://localhost:3000","type":"content","url":"/#build-and-preview","position":9},{"hierarchy":{"lvl1":"Introduction à Python","lvl2":"Deploying to GitHub Pages"},"type":"lvl2","url":"/#deploying-to-github-pages","position":10},{"hierarchy":{"lvl1":"Introduction à Python","lvl2":"Deploying to GitHub Pages"},"content":"","type":"content","url":"/#deploying-to-github-pages","position":11},{"hierarchy":{"lvl1":"Introduction à Python","lvl3":"Option 1: Using GitHub Actions (Recommended)","lvl2":"Deploying to GitHub Pages"},"type":"lvl3","url":"/#option-1-using-github-actions-recommended","position":12},{"hierarchy":{"lvl1":"Introduction à Python","lvl3":"Option 1: Using GitHub Actions (Recommended)","lvl2":"Deploying to GitHub Pages"},"content":"Push your code to GitHub\n\nThe GitHub Action will automatically build and deploy to GitHub Pages\n\nEnable GitHub Pages in your repository settings (Settings > Pages > Source: gh-pages branch)","type":"content","url":"/#option-1-using-github-actions-recommended","position":13},{"hierarchy":{"lvl1":"Introduction à Python","lvl3":"Option 2: Manual Deployment","lvl2":"Deploying to GitHub Pages"},"type":"lvl3","url":"/#option-2-manual-deployment","position":14},{"hierarchy":{"lvl1":"Introduction à Python","lvl3":"Option 2: Manual Deployment","lvl2":"Deploying to GitHub Pages"},"content":"Build the site:myst build --html\n\nThe built site will be in the _build/html directory\n\nDeploy to GitHub Pages:myst build --gh-pages","type":"content","url":"/#option-2-manual-deployment","position":15},{"hierarchy":{"lvl1":"Introduction à Python","lvl2":"Project Structure"},"type":"lvl2","url":"/#project-structure","position":16},{"hierarchy":{"lvl1":"Introduction à Python","lvl2":"Project Structure"},"content":".\n├── myst.yml              # MyST configuration\n├── index.md              # Homepage\n├── lectures/             # Lecture markdown files\n│   ├── lecture1.md\n│   └── lecture2.md\n├── requirements.txt      # Python dependencies\n└── README.md            # This file","type":"content","url":"/#project-structure","position":17},{"hierarchy":{"lvl1":"Introduction à Python","lvl2":"Adding New Lectures"},"type":"lvl2","url":"/#adding-new-lectures","position":18},{"hierarchy":{"lvl1":"Introduction à Python","lvl2":"Adding New Lectures"},"content":"Create a new markdown file in the lectures/ directory\n\nAdd the lecture to myst.yml under site.nav\n\nRebuild the site with myst build","type":"content","url":"/#adding-new-lectures","position":19},{"hierarchy":{"lvl1":"Introduction à Python","lvl2":"Resources"},"type":"lvl2","url":"/#resources","position":20},{"hierarchy":{"lvl1":"Introduction à Python","lvl2":"Resources"},"content":"MyST Documentation\n\nMyST Markdown Guide","type":"content","url":"/#resources","position":21},{"hierarchy":{"lvl1":"Cours Introduction à Python"},"type":"lvl1","url":"/","position":0},{"hierarchy":{"lvl1":"Cours Introduction à Python"},"content":"","type":"content","url":"/","position":1},{"hierarchy":{"lvl1":"Cours Introduction à Python","lvl2":"Introduction à Python"},"type":"lvl2","url":"/#introduction-python","position":2},{"hierarchy":{"lvl1":"Cours Introduction à Python","lvl2":"Introduction à Python"},"content":"Prof: Roman Schwalek\nPériode: 1er semestre 2026","type":"content","url":"/#introduction-python","position":3},{"hierarchy":{"lvl1":"Cours Introduction à Python","lvl3":"Course Overview","lvl2":"Introduction à Python"},"type":"lvl3","url":"/#course-overview","position":4},{"hierarchy":{"lvl1":"Cours Introduction à Python","lvl3":"Course Overview","lvl2":"Introduction à Python"},"content":"Cours sur les fondamentaux de Python avec une approche complète du développement avec les outils classiques comme git, uv et l’utilisation de la CLI.","type":"content","url":"/#course-overview","position":5},{"hierarchy":{"lvl1":"Cours Introduction à Python","lvl3":"Sessions","lvl2":"Introduction à Python"},"type":"lvl3","url":"/#sessions","position":6},{"hierarchy":{"lvl1":"Cours Introduction à Python","lvl3":"Sessions","lvl2":"Introduction à Python"},"content":"Session 1:\n\nSession 2:","type":"content","url":"/#sessions","position":7},{"hierarchy":{"lvl1":"Session 1 : Les Fondamentaux de Python pour le Développement"},"type":"lvl1","url":"/session1","position":0},{"hierarchy":{"lvl1":"Session 1 : Les Fondamentaux de Python pour le Développement"},"content":"","type":"content","url":"/session1","position":1},{"hierarchy":{"lvl1":"Session 1 : Les Fondamentaux de Python pour le Développement","lvl2":"Objectifs de la session"},"type":"lvl2","url":"/session1#objectifs-de-la-session","position":2},{"hierarchy":{"lvl1":"Session 1 : Les Fondamentaux de Python pour le Développement","lvl2":"Objectifs de la session"},"content":"Créer une classe Python et comprendre les méthodes spéciales : __init__, __repr__, __str__ et __len__\n\nComprendre la différence entre une classe et son instance\n\nUtiliser les type hints et comprendre les types de données\n\nImplémenter des fonctions et méthodes\n\nMaîtriser les rudiments de Git","type":"content","url":"/session1#objectifs-de-la-session","position":3},{"hierarchy":{"lvl1":"Session 1 : Les Fondamentaux de Python pour le Développement","lvl2":"Contexte du projet"},"type":"lvl2","url":"/session1#contexte-du-projet","position":4},{"hierarchy":{"lvl1":"Session 1 : Les Fondamentaux de Python pour le Développement","lvl2":"Contexte du projet"},"content":"Nous allons utiliser un projet de création de librairie Python comme prétexte pour découvrir les concepts de développement pythoniques essentiels. Cette librairie sera basée sur des concepts classiques de gestion de portefeuille.","type":"content","url":"/session1#contexte-du-projet","position":5},{"hierarchy":{"lvl1":"Session 1 : Les Fondamentaux de Python pour le Développement","lvl2":"Partie 1"},"type":"lvl2","url":"/session1#partie-1","position":6},{"hierarchy":{"lvl1":"Session 1 : Les Fondamentaux de Python pour le Développement","lvl2":"Partie 1"},"content":"","type":"content","url":"/session1#partie-1","position":7},{"hierarchy":{"lvl1":"Session 1 : Les Fondamentaux de Python pour le Développement","lvl3":"Étape 1.0 : Configuration du projet avec Git","lvl2":"Partie 1"},"type":"lvl3","url":"/session1#id-tape-1-0-configuration-du-projet-avec-git","position":8},{"hierarchy":{"lvl1":"Session 1 : Les Fondamentaux de Python pour le Développement","lvl3":"Étape 1.0 : Configuration du projet avec Git","lvl2":"Partie 1"},"content":"Avant de commencer à coder, configurons notre environnement de développement et initialisons notre dépôt Git.# Initialiser le dépôt Git local\ngit init --initial-branch main\n\n# Configurer votre identité Git\ngit config --global user.name \"VotreNom\"\ngit config --global user.email \"votre.email@example.com\"\n\n# Vérifier la configuration\ngit config --global --list\n\n# Créer le premier commit\ngit add .\ngit commit -m \"Initial commit: project structure\"\n\n# Lier à un dépôt distant après création sur GitHub\ngit remote add origin https://github.com/username/pyvest.git\ngit push -u origin main #(ou --set-upstream)","type":"content","url":"/session1#id-tape-1-0-configuration-du-projet-avec-git","position":9},{"hierarchy":{"lvl1":"Session 1 : Les Fondamentaux de Python pour le Développement","lvl3":"Étape 1.1 : L’objectif de cette session","lvl2":"Partie 1"},"type":"lvl3","url":"/session1#id-tape-1-1-lobjectif-de-cette-session","position":10},{"hierarchy":{"lvl1":"Session 1 : Les Fondamentaux de Python pour le Développement","lvl3":"Étape 1.1 : L’objectif de cette session","lvl2":"Partie 1"},"content":"La classe que l’on va construire au cours de cette session :import math\n\nclass PriceSeries:\n    \"\"\"\n    Représentation d'une série temporelle de prix financiers.\n    \n    Attributes:\n        values: Liste de prix indexés par le temps\n        name: Identifiant de la série\n    \n    Class Attributes:\n        TRADING_DAYS_PER_YEAR: Constante d'annualisation \n        (convention US equities, peut varier selon l'actif)\n    \"\"\"\n    \n    TRADING_DAYS_PER_YEAR: int = 252\n    \n    def __init__(self, values: list[float], name: str = \"unnamed\") -> None:\n        self.values = list(values)  # Copie défensive\n        self.name = name\n    \n    def __repr__(self) -> str:\n        return f\"PriceSeries({self.name!r}, {len(self.values)} values)\"\n    \n    def __str__(self) -> str:\n        if self.values:\n            return f\"{self.name}: {self.values[-1]:.2f} (latest)\"\n        return f\"{self.name}: empty\"\n    \n    def __len__(self) -> int:\n        return len(self.values)\n    \n    def linear_return(self, t: int) -> float:\n        \"\"\"\n        Calcule le rendement linéaire (arithmétique) entre t-1 et t.\n        \n        - Non ajusté des dividendes (utiliser le prix ajusté pour cela)\n        - Additif entre actifs : r_portfolio = Σ(weight_i × r_i)\n        \n        Args:\n            t: Position temporelle (doit être >= 1)\n\n        Returns:\n            Rendement en décimal (0.05 = 5%)\n        \"\"\"\n        return (self.values[t] - self.values[t-1]) / self.values[t-1]\n    \n    def log_return(self, t: int) -> float:\n        \"\"\"\n        Calcule le log-rendement entre t-1 et t.\n        \n        - Additif dans le temps : Σ(log returns) = log(P_T / P_0)\n        - Permet d'approximer la variance multipériode par la somme des variances\n        \n        Args:\n            t: index temporel\n\n        Returns:\n            Log-rendement\n        \"\"\"\n        return math.log(self.values[t] / self.values[t-1])\n    \n    @property\n    def total_return(self) -> float:\n        \"\"\"\n        Rendement total (non annualisé) sur toute la période.\n        \"\"\"\n        if len(self.values) < 2:\n            return 0.0\n        return (self.values[-1] - self.values[0]) / self.values[0]","type":"content","url":"/session1#id-tape-1-1-lobjectif-de-cette-session","position":11},{"hierarchy":{"lvl1":"Session 1 : Les Fondamentaux de Python pour le Développement","lvl3":"Étape 1.2 : Structure du projet","lvl2":"Partie 1"},"type":"lvl3","url":"/session1#id-tape-1-2-structure-du-projet","position":12},{"hierarchy":{"lvl1":"Session 1 : Les Fondamentaux de Python pour le Développement","lvl3":"Étape 1.2 : Structure du projet","lvl2":"Partie 1"},"content":"Comment démarrer rapidement le projet ? Profitez de la puissance de uv et de ses commandes intégrées:uv init pyvest --lib --package\n\nCette commande crée la structure suivante :pyvest/\n├── pyproject.toml      # Configuration du projet\n├── README.md           # fichier markdown pour présenter un repo git\n└── src/                # Dossier qui contient le code source de la librairie dans des modules / packages\n    └── pyvest/         \n        ├── __init__.py # Fait de pyvest un package\n        └── ...         # Nos modules iront ici\n\nCréons ensuite notre environnement virtuel :uv venv -p 3.12 .venv\nsource .venv/bin/activate","type":"content","url":"/session1#id-tape-1-2-structure-du-projet","position":13},{"hierarchy":{"lvl1":"Session 1 : Les Fondamentaux de Python pour le Développement","lvl3":"Module, Package et Librairie","lvl2":"Partie 1"},"type":"lvl3","url":"/session1#module-package-et-librairie","position":14},{"hierarchy":{"lvl1":"Session 1 : Les Fondamentaux de Python pour le Développement","lvl3":"Module, Package et Librairie","lvl2":"Partie 1"},"content":"Module : Un fichier Python (.py) contenant du code (fonctions, classes, variables) qui peut être importé par d’autres fichiers.\n\nPackage : Un répertoire contenant un fichier __init__.py et potentiellement d’autres modules ou sous-packages. Le __init__.py indique à Python que ce répertoire doit être traité comme un package importable.\n\nLibrairie : Une collection de code créée par un tiers, composée d’un ou plusieurs packages. L’utilisateur final n’a pas besoin de connaître le code interne ; il utilise simplement l’interface publique (API).\n\nAPI (Application Programming Interface) : L’interface publique d’une application. Elle définit comment d’autres programmes peuvent communiquer avec votre code (appeler des fonctions, instancier des classes, etc.).","type":"content","url":"/session1#module-package-et-librairie","position":15},{"hierarchy":{"lvl1":"Session 1 : Les Fondamentaux de Python pour le Développement","lvl3":"Étape 1.3 : Création de la première classe","lvl2":"Partie 1"},"type":"lvl3","url":"/session1#id-tape-1-3-cr-ation-de-la-premi-re-classe","position":16},{"hierarchy":{"lvl1":"Session 1 : Les Fondamentaux de Python pour le Développement","lvl3":"Étape 1.3 : Création de la première classe","lvl2":"Partie 1"},"content":"On peut créer notre premier fichier :\n(attention toutes les commandes sont en bash, demandez à votre LLM préféré pour les commandes en powershell)\n(Surtout essayez de comprendre les commandes et pas juste bêtement copier/coller)touch src/pyvest/priceseries.py# src/pyvest/priceseries.py\n\nclass PriceSeries:\n    pass\n\nOn peut tester dans le REPL (read-eval-print-loop) :>>> from pyvest.priceseries import PriceSeries\n>>> ps = PriceSeries()\n>>> ps\n<pyvest.priceseries.PriceSeries object at 0x...>\n>>> type(ps)\n<class 'pyvest.priceseries.PriceSeries'>","type":"content","url":"/session1#id-tape-1-3-cr-ation-de-la-premi-re-classe","position":17},{"hierarchy":{"lvl1":"Session 1 : Les Fondamentaux de Python pour le Développement","lvl3":"Qu’est-ce qu’une classe ?","lvl2":"Partie 1"},"type":"lvl3","url":"/session1#quest-ce-quune-classe","position":18},{"hierarchy":{"lvl1":"Session 1 : Les Fondamentaux de Python pour le Développement","lvl3":"Qu’est-ce qu’une classe ?","lvl2":"Partie 1"},"content":"Une classe est un patron / template qui définit la structure et le comportement d’un type d’objet. On peut la concevoir comme une usine capable de fabriquer des objets selon un modèle défini.\n\nLes objets créés à partir d’une classe sont appelés instances. Chaque instance possède :\n\nDes attributs : variables propres à l’instance\n\nDes méthodes : fonctions ayant accès aux attributs de l’instance# PriceSeries est la classe\n# ps1 et ps2 sont des instances (les objets créés)\nps1 = PriceSeries([100, 105, 110], \"close\")\nps2 = PriceSeries([50, 52, 51], \"close\")\n\n# Chaque instance a ses propres données\nps1.name\nps2.name\n\nNote sur pass : C’est une instruction qui ne fait rien. Elle permet juste de définir des structures vides (classes, fonctions) sans casser le code définit après.","type":"content","url":"/session1#quest-ce-quune-classe","position":19},{"hierarchy":{"lvl1":"Session 1 : Les Fondamentaux de Python pour le Développement","lvl3":"Expression vs Statement (Instruction)","lvl2":"Partie 1"},"type":"lvl3","url":"/session1#expression-vs-statement-instruction","position":20},{"hierarchy":{"lvl1":"Session 1 : Les Fondamentaux de Python pour le Développement","lvl3":"Expression vs Statement (Instruction)","lvl2":"Partie 1"},"content":"Petite distinction importante.\n\nUne expression est une combinaison de valeurs, variables et opérateurs qui s’évalue pour produire une valeur :# Expressions - chacune produit une valeur\n3 + 4              # → 7\nx * 2              # → valeur numérique\nlen(my_list)       # → int\na > b              # → booléen\n\"hello\".upper()    # → \"HELLO\"\n\nUn statement (instruction) est une unité de code qui effectue une action mais ne produit pas de valeur utilisable :# Statements - effectuent des actions\nif condition:      # Contrôle de flux\n    pass\nfor x in items:    # Boucle\n    pass\ndef ma_fonction(): # Définition de fonction\n    pass\nreturn valeur      # Retour de fonction (donc contrôle de flux)\nimport math        # Import\nx = 5              # Assignation\n\nCas particulier : L’opérateur morse := (walrus operator) permet une assignation qui est aussi une expression :\n\n# Assignation classique (statement)\nn = len(data)\nif n > 10:\n    print(n)\n\n# Avec walrus operator (statement + expression)\nif (n := len(data)) > 10:\n    print(n)","type":"content","url":"/session1#expression-vs-statement-instruction","position":21},{"hierarchy":{"lvl1":"Session 1 : Les Fondamentaux de Python pour le Développement","lvl3":"Étape 1.4 : La méthode __init__","lvl2":"Partie 1"},"type":"lvl3","url":"/session1#id-tape-1-4-la-m-thode-init","position":22},{"hierarchy":{"lvl1":"Session 1 : Les Fondamentaux de Python pour le Développement","lvl3":"Étape 1.4 : La méthode __init__","lvl2":"Partie 1"},"content":"La méthode __init__ est l’initialiseur de la classe. Elle est appelée automatiquement après la création de l’instance pour initialiser ses attributs.\n\nNote (peu importante) : On appelle souvent __init__ le “constructeur” par abus de langage mais le constructeur en Python est __new__, qui crée l’instance. __init__ reçoit cette instance déjà créée et l’initialise.class PriceSeries:\n    \n    TRADING_DAYS_PER_YEAR: int = 252  # Attribut de classe\n    \n    def __init__(self, values: list[float], name: str = \"unnamed\") -> None:\n        self.values = values  # Attribut d'instance\n        self.name = name      # Attribut d'instance\n\nLe paramètre self est une référence à l’instance spécifique en cours de création. Python le passe automatiquement lors de l’appel.# Ce que vous écrivez :\nps = PriceSeries([100, 105], \"close\")\n\n# Ce que Python exécute en coulisses (approximativement) :\ntype.__call__(PriceSeries, [[100, 105], \"close\"])\n# 1. Dans __call__, création de l'instance via __new__\ninstance = cls.__new__(PriceSeries)\n# 2. Initialisation via __init__\nPriceSeries.__init__(instance, [100, 105], \"close\")\n# 3. Assignation à la variable\nps = instance\n\nTest dans le REPL :>>> ps = PriceSeries([100.0, 102.5, 101.0, 105.0], \"close\")\n>>> ps.values\n[100.0, 102.5, 101.0, 105.0]\n>>> ps.name\n'close'\n>>> ps.TRADING_DAYS_PER_YEAR  # Accessible via l'instance\n252\n>>> PriceSeries.TRADING_DAYS_PER_YEAR  # Ou via la classe\n252","type":"content","url":"/session1#id-tape-1-4-la-m-thode-init","position":23},{"hierarchy":{"lvl1":"Session 1 : Les Fondamentaux de Python pour le Développement","lvl3":"Attributs de classe vs Attributs d’instance","lvl2":"Partie 1"},"type":"lvl3","url":"/session1#attributs-de-classe-vs-attributs-dinstance","position":24},{"hierarchy":{"lvl1":"Session 1 : Les Fondamentaux de Python pour le Développement","lvl3":"Attributs de classe vs Attributs d’instance","lvl2":"Partie 1"},"content":"Type\n\nDéfinition\n\nPartage\n\nExemple\n\nAttribut de classe\n\nDéfini directement dans la classe\n\nPartagé par toutes les instances\n\nTRADING_DAYS_PER_YEAR = 252\n\nAttribut d’instance\n\nDéfini via self.xxx dans __init__\n\nPropre à chaque instance\n\nself.values = values","type":"content","url":"/session1#attributs-de-classe-vs-attributs-dinstance","position":25},{"hierarchy":{"lvl1":"Session 1 : Les Fondamentaux de Python pour le Développement","lvl3":"Type Hints (Annotations de type)","lvl2":"Partie 1"},"type":"lvl3","url":"/session1#type-hints-annotations-de-type","position":26},{"hierarchy":{"lvl1":"Session 1 : Les Fondamentaux de Python pour le Développement","lvl3":"Type Hints (Annotations de type)","lvl2":"Partie 1"},"content":"Les type hints sont des annotations qui indiquent le type attendu des variables, paramètres et valeurs de retour :def __init__(self, values: list[float], name: str = \"unnamed\") -> None:\n#                  ↑               ↑              ↑              ↑\n#            paramètre      type attendu    valeur défaut   type retour\n\nPoints importants :\n\nPas d’effet à l’exécution : Python n’applique pas les types au runtime. Ce code fonctionne même si on passe des types incorrects.\n\nVérification statique : Les outils comme mypy, pyright ou l’IDE (VS Code/PyCharm) analysent les types avant l’exécution.\n\nDocumentation vivante : Les types rendent le code plus lisible et auto-documenté.# Ce code s'exécute sans erreur malgré les types incorrects\nps = PriceSeries(\"pas une liste\", 12345)\n# Mais un type checker signalerait le problème\n\nPrincipe de Postel (utile pour le typage) :\n\n“Soyez conservateur dans ce que vous envoyez, libéral dans ce que vous acceptez.”\n\nTypes courants :# Types simples\nx: int = 5\ny: float = 3.14\ns: str = \"hello\"\nb: bool = True\n\n# Types composés\nnumbers: list[float] = [1.0, 2.0]\nmapping: dict[str, int] = {\"a\": 1}\noptional: str | None = None","type":"content","url":"/session1#type-hints-annotations-de-type","position":27},{"hierarchy":{"lvl1":"Session 1 : Les Fondamentaux de Python pour le Développement","lvl3":"Étape 1.5 : Les méthodes __repr__ et __str__","lvl2":"Partie 1"},"type":"lvl3","url":"/session1#id-tape-1-5-les-m-thodes-repr-et-str","position":28},{"hierarchy":{"lvl1":"Session 1 : Les Fondamentaux de Python pour le Développement","lvl3":"Étape 1.5 : Les méthodes __repr__ et __str__","lvl2":"Partie 1"},"content":"Ces méthodes spéciales définissent comment votre objet est représenté sous forme de chaîne de caractères.class PriceSeries:\n    # ... (code précédent)\n    \n    def __repr__(self) -> str:\n        \"\"\"Représentation pour les développeurs (debugging).\"\"\"\n        return f\"PriceSeries({self.name!r}, {len(self.values)} values)\"\n    \n    def __str__(self) -> str:\n        \"\"\"Représentation pour les utilisateurs.\"\"\"\n        if self.values:\n            return f\"{self.name}: {self.values[-1]:.2f} (latest)\"\n        return f\"{self.name}: empty\"\n\nDifférence clé :\n\nMéthode\n\nAppelée par\n\nUsage\n\nFormat\n\n__repr__\n\nrepr(obj), REPL, debugger\n\nDéveloppement\n\nDoit ressembler au code pour recréer l’objet\n\n__str__\n\nstr(obj), print(obj)\n\nUtilisateur final\n\nLisible et claire>>> ps = PriceSeries([100.0, 102.5, 105.0], \"adjusted\")\n>>> ps                    # REPL appelle __repr__\n>>> print(ps)             # print() appelle __str__\n>>> repr(ps)\n>>> str(ps)\n\nAstuce !r dans les f-strings : L’expression {self.name!r} applique repr() à la valeur, affichant les guillemets pour les strings. Cela aide à distinguer PriceSeries('AAPL', ...) de PriceSeries(AAPL, ...).","type":"content","url":"/session1#id-tape-1-5-les-m-thodes-repr-et-str","position":29},{"hierarchy":{"lvl1":"Session 1 : Les Fondamentaux de Python pour le Développement","lvl3":"Le Python Data Model et les méthodes spéciales","lvl2":"Partie 1"},"type":"lvl3","url":"/session1#le-python-data-model-et-les-m-thodes-sp-ciales","position":30},{"hierarchy":{"lvl1":"Session 1 : Les Fondamentaux de Python pour le Développement","lvl3":"Le Python Data Model et les méthodes spéciales","lvl2":"Partie 1"},"content":"Le Python Data Model c’est l’API qu’on utilise pour que nos objets customisés intéragissent avec les fonctionnalités pré-intégrées à Python.\n\nLes méthodes spéciales (ou “dunder methods” pour “double underscore”) permettent à vos objets de s’intégrer naturellement avec les opérations Python :# Ce que vous écrivez          # Ce que Python appelle\nlen(obj)                       obj.__len__()\nstr(obj)                       obj.__str__()\nrepr(obj)                      obj.__repr__()\nobj[key]                       obj.__getitem__(key)\nobj1 + obj2                    obj1.__add__(obj2)\nfor x in obj:                  obj.__iter__()\n\nRègle importante : Vous n’appelez généralement pas ces méthodes directement. C’est l’interpréteur Python qui les appelle pour vous. Écrivez len(ts), pas ts.__len__().","type":"content","url":"/session1#le-python-data-model-et-les-m-thodes-sp-ciales","position":31},{"hierarchy":{"lvl1":"Session 1 : Les Fondamentaux de Python pour le Développement","lvl3":"Étape 1.6 : Premier commit Git","lvl2":"Partie 1"},"type":"lvl3","url":"/session1#id-tape-1-6-premier-commit-git","position":32},{"hierarchy":{"lvl1":"Session 1 : Les Fondamentaux de Python pour le Développement","lvl3":"Étape 1.6 : Premier commit Git","lvl2":"Partie 1"},"content":"Sauvegardons notre progression :# Voir les fichiers modifiés\ngit status\n\n# Ajouter les fichiers\ngit add src/pyvest/priceseries.py\n\n# Créer un commit avec un message descriptif\ngit commit -m \"feat: add PriceSeries class with __init__, __repr__, __str__\"\n\n# Vérifier l'historique\ngit log --oneline\n\nConvention de commit : Utilisez des messages clairs, par exemple suivant le format : type: description\n\nfeat: nouvelle fonctionnalité\n\nfix: correction de bug\n\ndocs: documentation\n\nrefactor: refactorisation sans changement fonctionnel","type":"content","url":"/session1#id-tape-1-6-premier-commit-git","position":33},{"hierarchy":{"lvl1":"Session 1 : Les Fondamentaux de Python pour le Développement","lvl3":"Étape 1.7 : Implémentation des méthodes de calcul de rendement","lvl2":"Partie 1"},"type":"lvl3","url":"/session1#id-tape-1-7-impl-mentation-des-m-thodes-de-calcul-de-rendement","position":34},{"hierarchy":{"lvl1":"Session 1 : Les Fondamentaux de Python pour le Développement","lvl3":"Étape 1.7 : Implémentation des méthodes de calcul de rendement","lvl2":"Partie 1"},"content":"import math\n\nclass PriceSeries:\n    # ... (code précédent)\n    \n    def linear_return(self, t: int) -> float:\n        \"\"\"Rendement linéaire (arithmétique) entre t-1 et t.\"\"\"\n        return (self.values[t] - self.values[t-1]) / self.values[t-1]\n    \n    def log_return(self, t: int) -> float:\n        \"\"\"Log-rendement entre t-1 et t.\"\"\"\n        return math.log(self.values[t] / self.values[t-1])\n\nTest dans le REPL :>>> ps = PriceSeries([100.0, 105.0, 103.0, 110.0], \"TEST\")\n>>> ps.linear_return(1)  # (105 - 100) / 100\n>>> ps.log_return(1)\n\n# On peut vérifier l'additivité des log-rendements\n>>> sum(ps.log_return(t) for t in range(1, len(ps.values)))\n>>> math.log(110 / 100)\n\nPropriétés des rendements :\n\nType\n\nAdditivité\n\nUsage principal\n\nLinéaire (arithmétique)\n\nEntre actifs : r_p = Σ(w_i × r_i)\n\nPortefeuille, cross-section\n\nLogarithmique\n\nDans le temps : r_total = Σ(r_t)\n\nSérie temporelle, volatilité","type":"content","url":"/session1#id-tape-1-7-impl-mentation-des-m-thodes-de-calcul-de-rendement","position":35},{"hierarchy":{"lvl1":"Session 1 : Les Fondamentaux de Python pour le Développement","lvl3":"Les fonctions en Python","lvl2":"Partie 1"},"type":"lvl3","url":"/session1#les-fonctions-en-python","position":36},{"hierarchy":{"lvl1":"Session 1 : Les Fondamentaux de Python pour le Développement","lvl3":"Les fonctions en Python","lvl2":"Partie 1"},"content":"Une fonction est un bloc de code réutilisable qui effectue une tâche spécifique.def nom_de_fonction(param1: type1, param2: type2 = valeur_defaut) -> type_retour:\n    \"\"\"Docstring décrivant la fonction.\"\"\"\n    # Corps de la fonction\n    resultat = param1 + param2\n    return resultat #optionnel\n\nComposants :\n\ndef : mot-clé introduisant la définition\n\nnom_de_fonction : identifiant (convention : snake_case, à la différence du camelCase par exemple)\n\nparam1, param2 : paramètres recevant des valeurs à l’appel\n\n-> type_retour : annotation du type de retour\n\nreturn : instruction optionnelle renvoyant une valeur\n\nAppel de fonction :# Appel positionnel\nresultat = nom_de_fonction(10, 20)\n\n# Appel avec arguments nommés (ordre modifiable)\nresultat = nom_de_fonction(param2=20, param1=10)\n\n# Mix des deux (positionnels d'abord)\nresultat = nom_de_fonction(10, param2=20)","type":"content","url":"/session1#les-fonctions-en-python","position":37},{"hierarchy":{"lvl1":"Session 1 : Les Fondamentaux de Python pour le Développement","lvl3":"Portée des variables (Scope)","lvl2":"Partie 1"},"type":"lvl3","url":"/session1#port-e-des-variables-scope","position":38},{"hierarchy":{"lvl1":"Session 1 : Les Fondamentaux de Python pour le Développement","lvl3":"Portée des variables (Scope)","lvl2":"Partie 1"},"content":"Python résout les noms de variables selon la règle LEGB :L - Local      : Variables définies dans la fonction courante\nE - Enclosing  : Variables des fonctions englobantes (closures)\nG - Global     : Variables au niveau du module\nB - Built-in   : Fonctions et constantes intégrées (len, print, True, ...)# GLOBAL\nx = \"global\"\n\ndef externe():\n    # ENCLOSING (pour interne)\n    y = \"enclosing\"\n    \n    def interne():\n        # LOCAL\n        z = \"local\"\n        print(z)  # → \"local\"\n        print(y)  # → \"enclosing\" (trouvé dans Enclosing)\n        print(x)  # → \"global\" (trouvé dans Global)\n        print(len)  # → <built-in function len> (Built-in)\n    \n    interne()\n\nexterne()\n\nPiège classique: Modifier une variable globale :compteur = 0\n\ndef incrementer():\n    compteur = compteur + 1  # UnboundLocalError\n    # Python crée une variable locale 'compteur' qui n'est pas encore définie\n\ndef incrementer_correct():\n    global compteur  # Déclare qu'on utilise la variable globale\n    compteur = compteur + 1","type":"content","url":"/session1#port-e-des-variables-scope","position":39},{"hierarchy":{"lvl1":"Session 1 : Les Fondamentaux de Python pour le Développement","lvl3":"Différence entre fonction Python et fonction mathématique","lvl2":"Partie 1"},"type":"lvl3","url":"/session1#diff-rence-entre-fonction-python-et-fonction-math-matique","position":40},{"hierarchy":{"lvl1":"Session 1 : Les Fondamentaux de Python pour le Développement","lvl3":"Différence entre fonction Python et fonction mathématique","lvl2":"Partie 1"},"content":"Aspect\n\nFonction mathématique\n\nFonction Python\n\nMapping\n\nUn élément de A → un unique élément de B\n\nPeut ne rien retourner (None)\n\nDéterminisme\n\nMême input → même output (toujours)\n\nPeut dépendre d’état externe\n\nEffets de bord\n\nAucun\n\nPeut modifier l’environnement","type":"content","url":"/session1#diff-rence-entre-fonction-python-et-fonction-math-matique","position":41},{"hierarchy":{"lvl1":"Session 1 : Les Fondamentaux de Python pour le Développement","lvl3":"Étape 1.8 : La méthode __len__","lvl2":"Partie 1"},"type":"lvl3","url":"/session1#id-tape-1-8-la-m-thode-len","position":42},{"hierarchy":{"lvl1":"Session 1 : Les Fondamentaux de Python pour le Développement","lvl3":"Étape 1.8 : La méthode __len__","lvl2":"Partie 1"},"content":"class PriceSeries:\n    # ... (code précédent)\n    \n    def __len__(self) -> int:\n        return len(self.values)\n\nCette méthode permet à nos instances de fonctionner avec la fonction built-in len() :>>> ps = PriceSeries([100.0, 105.0, 103.0, 110.0], \"TEST\")\n>>> len(ps)\n4\n>>> empty = PriceSeries([], \"EMPTY\")\n>>> len(empty)\n\nDuck Typing en action : Python ne vérifie pas le type ; il vérifie la présence de la méthode. Tout objet avec __len__ fonctionne avec len(). Pas besoin de type particulier.","type":"content","url":"/session1#id-tape-1-8-la-m-thode-len","position":43},{"hierarchy":{"lvl1":"Session 1 : Les Fondamentaux de Python pour le Développement","lvl3":"Concept fondamental : Duck Typing","lvl2":"Partie 1"},"type":"lvl3","url":"/session1#concept-fondamental-duck-typing","position":44},{"hierarchy":{"lvl1":"Session 1 : Les Fondamentaux de Python pour le Développement","lvl3":"Concept fondamental : Duck Typing","lvl2":"Partie 1"},"content":"“If it walks like a duck and quacks like a duck, it’s a duck.”\n\nLe duck typing signifie que Python se soucie des comportements (méthodes/attributs) plutôt que des types. Un objet est compatible avec une opération s’il implémente les méthodes nécessaires.def afficher_longueur(obj):\n    \"\"\"Fonctionne avec TOUT objet ayant __len__.\"\"\"\n    print(f\"Longueur: {len(obj)}\")\n\n# Tous ces appels fonctionnent !\nafficher_longueur([1, 2, 3])           # list\nafficher_longueur(\"hello\")              # str\nafficher_longueur({\"a\": 1, \"b\": 2})     # dict\nafficher_longueur(PriceSeries([100, 101, 102], \"X\"))  # notre classe !\n\nC’est pourquoi implémenter __len__ permet à PriceSeries de s’intégrer naturellement avec tout code utilisant len().","type":"content","url":"/session1#concept-fondamental-duck-typing","position":45},{"hierarchy":{"lvl1":"Session 1 : Les Fondamentaux de Python pour le Développement","lvl3":"Étape 1.9 : Le décorateur @property","lvl2":"Partie 1"},"type":"lvl3","url":"/session1#id-tape-1-9-le-d-corateur-property","position":46},{"hierarchy":{"lvl1":"Session 1 : Les Fondamentaux de Python pour le Développement","lvl3":"Étape 1.9 : Le décorateur @property","lvl2":"Partie 1"},"content":"class PriceSeries:\n    # ... (code précédent)\n    \n    @property\n    def total_return(self) -> float:\n        \"\"\"Rendement total sur toute la période.\"\"\"\n        if len(self.values) < 2:\n            return 0.0\n        return (self.values[-1] - self.values[0]) / self.values[0]\n\nLe décorateur @property transforme une méthode en attribut calculé :>>> ps = PriceSeries([100.0, 105.0, 103.0, 110.0], \"TEST\")\n>>> ps.total_return  # Pas de parenthèses car la méthode est accessible comme un attribut\n>>> f\"Rendement total: {ps.total_return:.2%}\"\n'Rendement total: 10.00%'\n\nAvantages de @property :\n\nSyntaxe propre : ps.total_return au lieu de ps.total_return()\n\nEncapsulation : Le calcul est caché derrière une interface simple\n\nLazy evaluation : Calculé uniquement quand on y accède\n\nQuand utiliser @property :\n\nValeur dérivée d’autres attributs\n\nPas d’effets de bord sur son environnement\n\nCalcul relativement léger\n\nOn verra plus en détails le concept de décorateur et son fonctionnement un peu plus tard dans le cours.","type":"content","url":"/session1#id-tape-1-9-le-d-corateur-property","position":47},{"hierarchy":{"lvl1":"Session 1 : Les Fondamentaux de Python pour le Développement","lvl3":"Les variables ne sont pas des boîtes","lvl2":"Partie 1"},"type":"lvl3","url":"/session1#les-variables-ne-sont-pas-des-bo-tes","position":48},{"hierarchy":{"lvl1":"Session 1 : Les Fondamentaux de Python pour le Développement","lvl3":"Les variables ne sont pas des boîtes","lvl2":"Partie 1"},"content":"Il faut penser les variables comme des étiquettes et non des boîtes.# On pourrait croire que b contient une COPIE de a\n# En réalité, a et b sont des étiquettes pointant vers le MÊME objet\n\na = [1, 2, 3]\nb = a           # b est une autre étiquette sur le même objet\na.append(4)\nprint(b)        # [1, 2, 3, 4] - b voit le changement !","type":"content","url":"/session1#les-variables-ne-sont-pas-des-bo-tes","position":49},{"hierarchy":{"lvl1":"Session 1 : Les Fondamentaux de Python pour le Développement","lvl3":"Concept fondamental : Objets mutables vs immutables","lvl2":"Partie 1"},"type":"lvl3","url":"/session1#concept-fondamental-objets-mutables-vs-immutables","position":50},{"hierarchy":{"lvl1":"Session 1 : Les Fondamentaux de Python pour le Développement","lvl3":"Concept fondamental : Objets mutables vs immutables","lvl2":"Partie 1"},"content":"Type\n\nMutabilité\n\nExemples\n\nImmutable\n\nNe peut pas être modifié après création\n\nint, float, str, tuple, frozenset\n\nMutable\n\nPeut être modifié après création\n\nlist, dict, set, objets personnalisés# Immutable: l'objet original n'est pas modifié\nx = 5\ny = x\nx = x + 1  # Crée un NOUVEL objet int\nprint(y)   # 5 car y pointe toujours vers l'ancien objet car immutable\n\n# Mutable: l'objet original EST modifié\n# Voir l'exemple précédent de la liste pour démontré\n# qu'une variable n'est pas une boîte\n\nImplication pour PriceSeries :# Danger potentiel\nprices = [100, 105, 110]\nps = PriceSeries(prices, \"TEST\")\nprices.append(115)  # Modifie aussi ps.values\nprint(ps.values)    # [100, 105, 110, 115]\n\n# Solution : copie défensive dans __init__\ndef __init__(self, values: list[float], name: str = \"unnamed\") -> None:\n    self.values = list(values)  # Crée une COPIE de la liste\n    self.name = name","type":"content","url":"/session1#concept-fondamental-objets-mutables-vs-immutables","position":51},{"hierarchy":{"lvl1":"Session 1 : Les Fondamentaux de Python pour le Développement","lvl3":"Disinction d’opérateur: is vs ==","lvl2":"Partie 1"},"type":"lvl3","url":"/session1#disinction-dop-rateur-is-vs","position":52},{"hierarchy":{"lvl1":"Session 1 : Les Fondamentaux de Python pour le Développement","lvl3":"Disinction d’opérateur: is vs ==","lvl2":"Partie 1"},"content":"Opérateur\n\nCompare\n\nQuestion posée\n\n==\n\nLes valeurs\n\n“Est ce que les variables pointent vers des objets avec la même valeur ?”\n\nis\n\nL’identité (adresse mémoire)\n\n“Sont-ils le même objet en mémoire ?”a = [1, 2, 3]\nb = [1, 2, 3]\nc = a\n\na == b   # True  - mêmes valeurs\na is b   # False - objets différents\na == c   # True  - mêmes valeurs\na is c   # True  - même objet\n\n# Vérification avec id()\nid(a)    # 140234567890\nid(b)    # 140234567891 - différent !\nid(c)    # 140234567890 - identique à a","type":"content","url":"/session1#disinction-dop-rateur-is-vs","position":53},{"hierarchy":{"lvl1":"Session 1 : Les Fondamentaux de Python pour le Développement","lvl3":"Slicing (découpage)","lvl2":"Partie 1"},"type":"lvl3","url":"/session1#slicing-d-coupage","position":54},{"hierarchy":{"lvl1":"Session 1 : Les Fondamentaux de Python pour le Développement","lvl3":"Slicing (découpage)","lvl2":"Partie 1"},"content":"Le slicing permet d’extraire des sous-séquences avec la syntaxe sequence[start:stop:step] :prices = [100, 105, 103, 110, 108, 112]\n#          0    1    2    3    4    5   (indices positifs)\n#         -6   -5   -4   -3   -2   -1   (indices négatifs)\n\n# Quelques exemples d'extraction de base\nprices[0]       # 100 - premier élément\nprices[-1]      # 112 - dernier élément\nprices[1:4]     # [105, 103, 110] - indices 1, 2, 3\nprices[:3]      # [100, 105, 103] - du début à l'indice 2\nprices[3:]      # [110, 108, 112] - de l'indice 3 à la fin\nprices[::2]     # [100, 103, 108] - un élément sur deux\nprices[::-1]    # [112, 108, 110, 103, 105, 100] - inversé\n\n# Utilisé dans notre code\npeak = max(self.values[:t+1])  # Maximum du début jusqu'à t (inclus)\nlast_price = self.values[-1]   # Dernier prix","type":"content","url":"/session1#slicing-d-coupage","position":55},{"hierarchy":{"lvl1":"Session 1 : Les Fondamentaux de Python pour le Développement","lvl3":"Gestion des erreurs (Exceptions)","lvl2":"Partie 1"},"type":"lvl3","url":"/session1#gestion-des-erreurs-exceptions","position":56},{"hierarchy":{"lvl1":"Session 1 : Les Fondamentaux de Python pour le Développement","lvl3":"Gestion des erreurs (Exceptions)","lvl2":"Partie 1"},"content":"Les exceptions signalent des conditions anormales. Sans gestion, elles arrêtent le programme.# peut planter\ndef linear_return(self, t: int) -> float:\n    return (self.values[t] - self.values[t-1]) / self.values[t-1]\n    # si t=0 ? → values[-1] donc calcul faussé\n    # si t=100 et len(values)=50 on aura une IndexError\n\n# robuste avec validation\ndef linear_return(self, t: int) -> float:\n    if t < 1:\n        raise ValueError(f\"t doit être >= 1, reçu: {t}\")\n    if t >= len(self.values):\n        raise IndexError(f\"t={t} hors limites (max: {len(self.values)-1})\")\n    return (self.values[t] - self.values[t-1]) / self.values[t-1]\n\nGestion avec try/except :try:\n    ret = ts.linear_return(0)\nexcept ValueError as e:\n    print(f\"Erreur de valeur: {e}\")\nexcept IndexError as e:\n    print(f\"Index hors limites: {e}\")\n\nOn peut également conclure un statement try/except par un finally pour exécuter une instruction dans tous les cas, qu’une exception soit catch ou pas.\n\nExceptions courantes :\n\nException\n\nCause typique\n\nValueError\n\nValeur incorrecte mais type correct\n\nTypeError\n\nType incorrect\n\nIndexError\n\nIndex hors limites d’une séquence\n\nKeyError\n\nClé absente d’un dictionnaire\n\nZeroDivisionError\n\nDivision par zéro\n\nFileNotFoundError\n\nFichier introuvable","type":"content","url":"/session1#gestion-des-erreurs-exceptions","position":57},{"hierarchy":{"lvl1":"Session 1 : Les Fondamentaux de Python pour le Développement","lvl3":"Étape 1.10 : Deuxième commit","lvl2":"Partie 1"},"type":"lvl3","url":"/session1#id-tape-1-10-deuxi-me-commit","position":58},{"hierarchy":{"lvl1":"Session 1 : Les Fondamentaux de Python pour le Développement","lvl3":"Étape 1.10 : Deuxième commit","lvl2":"Partie 1"},"content":"git add .\ngit commit -m \"feat(core): add return calculations and __len__ to PriceSeries\"","type":"content","url":"/session1#id-tape-1-10-deuxi-me-commit","position":59},{"hierarchy":{"lvl1":"Session 1 : Les Fondamentaux de Python pour le Développement","lvl2":"Partie 2 : Exercices Pratiques"},"type":"lvl2","url":"/session1#partie-2-exercices-pratiques","position":60},{"hierarchy":{"lvl1":"Session 1 : Les Fondamentaux de Python pour le Développement","lvl2":"Partie 2 : Exercices Pratiques"},"content":"","type":"content","url":"/session1#partie-2-exercices-pratiques","position":61},{"hierarchy":{"lvl1":"Session 1 : Les Fondamentaux de Python pour le Développement","lvl3":"Exercice 1 : Calcul du vecteur de rendements","lvl2":"Partie 2 : Exercices Pratiques"},"type":"lvl3","url":"/session1#exercice-1-calcul-du-vecteur-de-rendements","position":62},{"hierarchy":{"lvl1":"Session 1 : Les Fondamentaux de Python pour le Développement","lvl3":"Exercice 1 : Calcul du vecteur de rendements","lvl2":"Partie 2 : Exercices Pratiques"},"content":"Implémentez deux méthodes retournant la liste de tous les rendements :def get_all_linear_returns(self) -> list[float]:\n    \"\"\"Retourne la liste de tous les rendements linéaires.\n\n    Returns:\n        Liste de n-1 rendements pour n prix.\n    \"\"\"\n    # Votre code ici\n    pass\n\ndef get_all_log_returns(self) -> list[float]:\n    \"\"\"Retourne la liste de tous les log-rendements.\"\"\"\n    # Votre code ici\n    pass","type":"content","url":"/session1#exercice-1-calcul-du-vecteur-de-rendements","position":63},{"hierarchy":{"lvl1":"Session 1 : Les Fondamentaux de Python pour le Développement","lvl3":"Exercice 2 : Volatilité annualisée","lvl2":"Partie 2 : Exercices Pratiques"},"type":"lvl3","url":"/session1#exercice-2-volatilit-annualis-e","position":64},{"hierarchy":{"lvl1":"Session 1 : Les Fondamentaux de Python pour le Développement","lvl3":"Exercice 2 : Volatilité annualisée","lvl2":"Partie 2 : Exercices Pratiques"},"content":"def annualized_volatility(self) -> float:\n    \"\"\"\n    Volatilité annualisée à partir des log-rendements.\n    \n    Formule: σ_annual = σ_daily × √252\n    \n    Note: Le scaling √252 suppose des rendements i.i.d\n    Cette hypothèse est rarement vérifiée en pratique \n    (clustering de volatilité).\n    \n    Pour une meilleure estimation, considérer:\n    - Modèles GARCH\n    - Moyenne mobile exponentielle (EWMA)\n    \"\"\"\n    # Étapes:\n    # 1. Obtenir tous les log-rendements\n    # 2. Calculer la moyenne\n    # 3. Calculer la variance d'échantillon (diviser par n-1)\n    # 4. Prendre la racine carrée pour la volatilité quotidienne\n    # 5. Annualiser: × √252\n    pass","type":"content","url":"/session1#exercice-2-volatilit-annualis-e","position":65},{"hierarchy":{"lvl1":"Session 1 : Les Fondamentaux de Python pour le Développement","lvl3":"Exercice 3 : Ratio de Sharpe","lvl2":"Partie 2 : Exercices Pratiques"},"type":"lvl3","url":"/session1#exercice-3-ratio-de-sharpe","position":66},{"hierarchy":{"lvl1":"Session 1 : Les Fondamentaux de Python pour le Développement","lvl3":"Exercice 3 : Ratio de Sharpe","lvl2":"Partie 2 : Exercices Pratiques"},"content":"def annualized_return(self) -> float:\n    \"\"\"\n    Rendement annuel moyen à partir des log-rendements.\n    Formule: μ_annual = μ_daily × 252\n    \"\"\"\n    pass\n\ndef sharpe_ratio(self, risk_free_rate: float = 0.0) -> float:\n    \"\"\"\n    Ratio de sharpe annualisé : \n            - ratio entre les rendements esperés d'une stratégie et sa volatilité\n            - rendement par unité de risque\n        \n        Formule: SR = (μ - r_f) / σ\n        \n        Args:\n            risk_free_rate: taux sans risque annuel\n    \"\"\"\n    pass","type":"content","url":"/session1#exercice-3-ratio-de-sharpe","position":67},{"hierarchy":{"lvl1":"Session 1 : Les Fondamentaux de Python pour le Développement","lvl3":"Exercice 4 : Max drawdown","lvl2":"Partie 2 : Exercices Pratiques"},"type":"lvl3","url":"/session1#exercice-4-max-drawdown","position":68},{"hierarchy":{"lvl1":"Session 1 : Les Fondamentaux de Python pour le Développement","lvl3":"Exercice 4 : Max drawdown","lvl2":"Partie 2 : Exercices Pratiques"},"content":"def drawdown_at(self, t: int) -> float:\n    \"\"\"\n    Retourne le drawdown à l'instant t depuis le début de la série.\n    Mesure le déclin par rapport à un pique historique.\n\n    Args:\n        t (int): index de position de la valeur supérieure de l'intervalle considéré.\n\n    Returns:\n        float: drawdown\n    \"\"\"\n    pass\n\ndef max_drawdown(self) -> float:\n    \"\"\"\n    Drawdown maximum sur toute la série.\n    \n    Returns:\n        Drawdown maximum (valeur négative ou zéro)\n    \"\"\"\n    pass","type":"content","url":"/session1#exercice-4-max-drawdown","position":69},{"hierarchy":{"lvl1":"Session 1 : Les Fondamentaux de Python pour le Développement","lvl3":"Commit final","lvl2":"Partie 2 : Exercices Pratiques"},"type":"lvl3","url":"/session1#commit-final","position":70},{"hierarchy":{"lvl1":"Session 1 : Les Fondamentaux de Python pour le Développement","lvl3":"Commit final","lvl2":"Partie 2 : Exercices Pratiques"},"content":"git add .\ngit commit -m \"features: add volatility, sharpe, drawdown to PriceSeries\"","type":"content","url":"/session1#commit-final","position":71},{"hierarchy":{"lvl1":"Session 1 : Les Fondamentaux de Python pour le Développement","lvl2":"Solutions"},"type":"lvl2","url":"/session1#solutions","position":72},{"hierarchy":{"lvl1":"Session 1 : Les Fondamentaux de Python pour le Développement","lvl2":"Solutions"},"content":"","type":"content","url":"/session1#solutions","position":73},{"hierarchy":{"lvl1":"Session 1 : Les Fondamentaux de Python pour le Développement","lvl3":"Solution - Exercice 1","lvl2":"Solutions"},"type":"lvl3","url":"/session1#solution-exercice-1","position":74},{"hierarchy":{"lvl1":"Session 1 : Les Fondamentaux de Python pour le Développement","lvl3":"Solution - Exercice 1","lvl2":"Solutions"},"content":"def get_all_linear_returns(self) -> list[float]:\n    \"\"\"Retourne la liste de tous les rendements linéaires.\"\"\"\n    return [self.linear_return(t) for t in range(1, len(self.values))]\n\ndef get_all_log_returns(self) -> list[float]:\n    \"\"\"Retourne la liste de tous les log-rendements.\"\"\"\n    return [self.log_return(t) for t in range(1, len(self.values))]","type":"content","url":"/session1#solution-exercice-1","position":75},{"hierarchy":{"lvl1":"Session 1 : Les Fondamentaux de Python pour le Développement","lvl3":"Solution - Exercice 2","lvl2":"Solutions"},"type":"lvl3","url":"/session1#solution-exercice-2","position":76},{"hierarchy":{"lvl1":"Session 1 : Les Fondamentaux de Python pour le Développement","lvl3":"Solution - Exercice 2","lvl2":"Solutions"},"content":"def annualized_volatility(self) -> float:\n    if len(self.values) < 3:\n            raise ValueError(\"Not enough data points\")\n            \n    log_returns = self.get_all_log_returns()\n    n = len(log_returns)\n    mean = sum(log_returns) / n\n    var = sum((l_r - mean)**2 for l_r in log_returns) / (n - 1)\n    daily_vol = math.sqrt(var)\n\n    return daily_vol * math.sqrt(self.TRADING_DAYS_PER_YEAR)","type":"content","url":"/session1#solution-exercice-2","position":77},{"hierarchy":{"lvl1":"Session 1 : Les Fondamentaux de Python pour le Développement","lvl3":"Solution - Exercice 3","lvl2":"Solutions"},"type":"lvl3","url":"/session1#solution-exercice-3","position":78},{"hierarchy":{"lvl1":"Session 1 : Les Fondamentaux de Python pour le Développement","lvl3":"Solution - Exercice 3","lvl2":"Solutions"},"content":"def annualized_return(self) -> float:\n    \"\"\"\n    Retourne le rendement annualisé sur toute la période.\n    \"\"\"\n    if len(self) < 2:\n        raise ValueError(\"Not enough data points\")\n    r = self.get_all_log_returns()\n    return (sum(r) / len(r)) * self.TRADING_DAYS_PER_YEAR\n\ndef sharpe_ratio(self, risk_free_rate: float = 0.0) -> float:\n    \"\"\"\n    Ratio de sharpe annualisé : \n        - ratio entre les rendements esperés d'une stratégie et sa vol\n        - rendement par unité de risque\n    \n    Formule: SR = (μ - r_f) / σ\n    \n    Args:\n        risk_free_rate: taux sans risque annuel\n    \n    \"\"\"\n    vol = self.annualized_volatility()\n    if vol == 0:\n        return 0.0\n    excess_return = self.annualized_return() - risk_free_rate\n    return excess_return / vol","type":"content","url":"/session1#solution-exercice-3","position":79},{"hierarchy":{"lvl1":"Session 1 : Les Fondamentaux de Python pour le Développement","lvl3":"Solution - Exercice 4","lvl2":"Solutions"},"type":"lvl3","url":"/session1#solution-exercice-4","position":80},{"hierarchy":{"lvl1":"Session 1 : Les Fondamentaux de Python pour le Développement","lvl3":"Solution - Exercice 4","lvl2":"Solutions"},"content":"def drawdown_at(self, t: int) -> float:\n    \"\"\"Drawdown au temps t.\"\"\"\n    if t < 0 or t >= len(self.values):\n        raise IndexError(f\"index {t} is out of range for series of length {len(self.values)}\")\n\n    peak = max(self.values[:t+1])\n    if peak == 0:\n        return 0.0\n    return (self.values[t] - peak) / peak\n\ndef max_drawdown(self) -> float:\n    \"\"\"Drawdown maximum sur toute la série.\"\"\"\n    max_dd = 0.0\n    peak = self.values[0]\n\n    for value in self.values[1:]:\n        peak = max(peak, value)\n        if peak > 0:\n            dd = (value - peak) / peak\n            max_dd = min(max_dd, dd)\n\n    return max_dd","type":"content","url":"/session1#solution-exercice-4","position":81},{"hierarchy":{"lvl1":"Session 2 : Composition de Classes et Chargement de Données"},"type":"lvl1","url":"/session2","position":0},{"hierarchy":{"lvl1":"Session 2 : Composition de Classes et Chargement de Données"},"content":"","type":"content","url":"/session2","position":1},{"hierarchy":{"lvl1":"Session 2 : Composition de Classes et Chargement de Données","lvl2":"Objectifs de la session"},"type":"lvl2","url":"/session2#objectifs-de-la-session","position":2},{"hierarchy":{"lvl1":"Session 2 : Composition de Classes et Chargement de Données","lvl2":"Objectifs de la session"},"content":"Introduire la programmation orientée-objet et les principes fondamentaux de conception de classes\n\nUtiliser les types de collections intégrés à Python (listes, dictionnaires, ensembles)\n\nMaîtriser la syntaxe des expressions de compréhension\n\nRécupérer des données à partir d’APIs publiques\n\nImplémenter un système de cache avec gestion des chevauchements temporels","type":"content","url":"/session2#objectifs-de-la-session","position":3},{"hierarchy":{"lvl1":"Session 2 : Composition de Classes et Chargement de Données","lvl2":"Contexte du projet"},"type":"lvl2","url":"/session2#contexte-du-projet","position":4},{"hierarchy":{"lvl1":"Session 2 : Composition de Classes et Chargement de Données","lvl2":"Contexte du projet"},"content":"Dans la Session 1, nous avons créé notre classe PriceSeries pour représenter et manipuler des séries de prix. Nous pouvons maintenant construire des abstractions de plus haut niveau :\n\nUne classe Asset qui contient une PriceSeries (composition)\n\nUne classe DataLoader pour récupérer des données de marché avec cache intelligent\n\nUne classe Universe pour gérer une collection d’actifs","type":"content","url":"/session2#contexte-du-projet","position":5},{"hierarchy":{"lvl1":"Session 2 : Composition de Classes et Chargement de Données","lvl3":"Architecture cible","lvl2":"Contexte du projet"},"type":"lvl3","url":"/session2#architecture-cible","position":6},{"hierarchy":{"lvl1":"Session 2 : Composition de Classes et Chargement de Données","lvl3":"Architecture cible","lvl2":"Contexte du projet"},"content":"┌─────────────────────────────────────────────────────────────┐\n│                        Universe                              │\n│  ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐        │\n│  │  Asset  │  │  Asset  │  │  Asset  │  │  Asset  │  ...   │\n│  │  AAPL   │  │  MSFT   │  │  GOOGL  │  │  AMZN   │        │\n│  └────┬────┘  └────┬────┘  └────┬────┘  └────┬────┘        │\n│       │            │            │            │              │\n│  ┌────▼────┐  ┌────▼────┐  ┌────▼────┐  ┌────▼────┐        │\n│  │  Price  │  │  Price  │  │  Price  │  │  Price  │        │\n│  │  Series │  │  Series │  │  Series │  │  Series │        │\n│  └─────────┘  └─────────┘  └─────────┘  └─────────┘        │\n└─────────────────────────────────────────────────────────────┘\n                            ▲\n                            │ fetch\n                    ┌───────┴───────┐\n                    │  DataLoader   │\n                    │  (+ cache)    │\n                    └───────────────┘","type":"content","url":"/session2#architecture-cible","position":7},{"hierarchy":{"lvl1":"Session 2 : Composition de Classes et Chargement de Données","lvl3":"Exemple d’utilisation finale","lvl2":"Contexte du projet"},"type":"lvl3","url":"/session2#exemple-dutilisation-finale","position":8},{"hierarchy":{"lvl1":"Session 2 : Composition de Classes et Chargement de Données","lvl3":"Exemple d’utilisation finale","lvl2":"Contexte du projet"},"content":"from pyvest.core.priceseries import PriceSeries\nfrom pyvest.core.asset import Asset\nfrom pyvest.data.loader import DataLoader\nfrom pyvest.core.universe import Universe\n\n# Instanciation du DataLoader avec système de cache\nloader = DataLoader(cache_dir=\".cache\")\n\n# Récupération des données pour un actif via l'API Yahoo Finance\napple_ts = loader.fetch_single_ticker(\"AAPL\", \"Close\", (\"2024-01-01\", \"2024-12-01\"))\n\n# Test du système de cache (le second appel devrait être instantané)\napple_ts = loader.fetch_single_ticker(\"AAPL\", \"Close\", (\"2024-01-01\", \"2024-12-01\"))\n\n# Création de nos objets Asset\napple = Asset(\"AAPL\", apple_ts, sector=\"Technology\")\nmsft = Asset(\"MSFT\", loader.fetch_single_ticker(\"MSFT\", \"Close\", (\"2024-01-01\", \"2024-12-01\")), sector=\"Technology\")\n\n# Communication entre Asset et son interface PriceSeries\nprint(f\"Volatilité AAPL: {apple.volatility:.2%}\")\n\n# Corrélation entre deux actifs\ncorrelation = apple.correlation_with(msft)\nprint(f\"Corrélation AAPL-MSFT: {correlation:.2f}\")\n\n# Agrégation dans un objet Universe\nuniverse = Universe([apple, msft])\nfor asset in universe:\n    print(f\"{asset.ticker}: {asset.total_return:.2%}\")","type":"content","url":"/session2#exemple-dutilisation-finale","position":9},{"hierarchy":{"lvl1":"Session 2 : Composition de Classes et Chargement de Données","lvl2":"Partie 1 : Développement Guidé"},"type":"lvl2","url":"/session2#partie-1-d-veloppement-guid","position":10},{"hierarchy":{"lvl1":"Session 2 : Composition de Classes et Chargement de Données","lvl2":"Partie 1 : Développement Guidé"},"content":"","type":"content","url":"/session2#partie-1-d-veloppement-guid","position":11},{"hierarchy":{"lvl1":"Session 2 : Composition de Classes et Chargement de Données","lvl3":"Étape 2.1 : La classe Asset et le pattern Composition","lvl2":"Partie 1 : Développement Guidé"},"type":"lvl3","url":"/session2#id-tape-2-1-la-classe-asset-et-le-pattern-composition","position":12},{"hierarchy":{"lvl1":"Session 2 : Composition de Classes et Chargement de Données","lvl3":"Étape 2.1 : La classe Asset et le pattern Composition","lvl2":"Partie 1 : Développement Guidé"},"content":"","type":"content","url":"/session2#id-tape-2-1-la-classe-asset-et-le-pattern-composition","position":13},{"hierarchy":{"lvl1":"Session 2 : Composition de Classes et Chargement de Données","lvl4":"Introduction à la Programmation Orientée Objet","lvl3":"Étape 2.1 : La classe Asset et le pattern Composition","lvl2":"Partie 1 : Développement Guidé"},"type":"lvl4","url":"/session2#introduction-la-programmation-orient-e-objet","position":14},{"hierarchy":{"lvl1":"Session 2 : Composition de Classes et Chargement de Données","lvl4":"Introduction à la Programmation Orientée Objet","lvl3":"Étape 2.1 : La classe Asset et le pattern Composition","lvl2":"Partie 1 : Développement Guidé"},"content":"La programmation orientée-objet (POO) est un paradigme qui permet de structurer le code autour d’objets — des entités définies par leurs caractéristiques (attributs) et leurs comportements (méthodes). Une classe agit comme un patron (ou usine) capable de produire des objets d’un type donné.\n\nLes trois piliers de la POO :\n\nPilier\n\nDescription\n\nExemple\n\nEncapsulation\n\nRegrouper données et comportements dans une même unité\n\nAsset encapsule ticker, prix, secteur\n\nAbstraction\n\nExposer une interface simple, cacher la complexité\n\nasset.volatility cache le calcul sous-jacent\n\nPolymorphisme\n\nObjets de types différents répondant à la même interface\n\nTout objet avec __len__ fonctionne avec len()\n\nNote importante : La POO n’est pas toujours nécessaire. Un programme simple peut fonctionner plus clairement comme une combinaison de fonctions. Voir la présentation de Jack Diederich “Stop Writing Classes” (PyCon 2012). Cependant, pour une librairie structurée comme la nôtre, la POO apporte une organisation claire et maintenable.","type":"content","url":"/session2#introduction-la-programmation-orient-e-objet","position":15},{"hierarchy":{"lvl1":"Session 2 : Composition de Classes et Chargement de Données","lvl4":"Analyse des besoins","lvl3":"Étape 2.1 : La classe Asset et le pattern Composition","lvl2":"Partie 1 : Développement Guidé"},"type":"lvl4","url":"/session2#analyse-des-besoins","position":16},{"hierarchy":{"lvl1":"Session 2 : Composition de Classes et Chargement de Données","lvl4":"Analyse des besoins","lvl3":"Étape 2.1 : La classe Asset et le pattern Composition","lvl2":"Partie 1 : Développement Guidé"},"content":"Avant de coder, identifions les classes principales et leurs responsabilités :\n\nClasse\n\nResponsabilité\n\nAttributs\n\nMéthodes\n\nPriceSeries\n\nStocke et opère sur une série de prix\n\nvalues, name\n\nlog_return(), volatility()\n\nAsset\n\nReprésente un actif financier et ses métadonnées\n\nticker, prices, sector\n\ncorrelation_with(), propriétés métriques\n\nDataLoader\n\nRécupère et met en cache les données de marché\n\ncache_dir\n\nfetch_single_ticker(), fetch_multiple_tickers()\n\nUniverse\n\nGère une collection d’actifs\n\n_assets\n\nadd(), get(), filter_by_sector()","type":"content","url":"/session2#analyse-des-besoins","position":17},{"hierarchy":{"lvl1":"Session 2 : Composition de Classes et Chargement de Données","lvl4":"Les principes SOLID","lvl3":"Étape 2.1 : La classe Asset et le pattern Composition","lvl2":"Partie 1 : Développement Guidé"},"type":"lvl4","url":"/session2#les-principes-solid","position":18},{"hierarchy":{"lvl1":"Session 2 : Composition de Classes et Chargement de Données","lvl4":"Les principes SOLID","lvl3":"Étape 2.1 : La classe Asset et le pattern Composition","lvl2":"Partie 1 : Développement Guidé"},"content":"Ces principes guident la conception de classes robustes et maintenables :\n\nPrincipe\n\nDescription\n\nApplication\n\nSingle Responsibility\n\nUne classe = une responsabilité claire\n\nDataLoader ne fait que charger des données\n\nOpen/Closed\n\nExtensible sans modification interne\n\nHéritage pour spécialiser Asset\n\nLiskov Substitution\n\nSous-classes substituables aux parents\n\nPolymorphisme\n\nInterface Segregation\n\nInterfaces minimales et ciblées\n\nMéthodes publiques essentielles uniquement\n\nDependency Inversion\n\nDépendre d’abstractions, pas d’implémentations\n\nInjection de dépendances","type":"content","url":"/session2#les-principes-solid","position":19},{"hierarchy":{"lvl1":"Session 2 : Composition de Classes et Chargement de Données","lvl4":"Types de relations entre classes","lvl3":"Étape 2.1 : La classe Asset et le pattern Composition","lvl2":"Partie 1 : Développement Guidé"},"type":"lvl4","url":"/session2#types-de-relations-entre-classes","position":20},{"hierarchy":{"lvl1":"Session 2 : Composition de Classes et Chargement de Données","lvl4":"Types de relations entre classes","lvl3":"Étape 2.1 : La classe Asset et le pattern Composition","lvl2":"Partie 1 : Développement Guidé"},"content":"Relation\n\nQuestion à se poser\n\nExemple\n\nComposition\n\n“B appartient-il à A ? Le cycle de vie de B dépend-il de A ?”\n\nAsset contient une PriceSeries\n\nAgrégation\n\n“A contient-il B alors que B peut exister indépendamment ?”\n\nUniverse contient des Asset\n\nHéritage\n\n“A est-il un type spécialisé de B ?”\n\nNon utilisé pour l’instant","type":"content","url":"/session2#types-de-relations-entre-classes","position":21},{"hierarchy":{"lvl1":"Session 2 : Composition de Classes et Chargement de Données","lvl4":"Implémentation de la classe Asset","lvl3":"Étape 2.1 : La classe Asset et le pattern Composition","lvl2":"Partie 1 : Développement Guidé"},"type":"lvl4","url":"/session2#impl-mentation-de-la-classe-asset","position":22},{"hierarchy":{"lvl1":"Session 2 : Composition de Classes et Chargement de Données","lvl4":"Implémentation de la classe Asset","lvl3":"Étape 2.1 : La classe Asset et le pattern Composition","lvl2":"Partie 1 : Développement Guidé"},"content":"# Fichier: pyvest/core/asset.py\n\nfrom pyvest.core.priceseries import PriceSeries\nfrom enum import Enum\n\n\nclass CurrencyEnum(Enum):\n    \"\"\"Énumération des devises supportées.\"\"\"\n    USD = \"USD\"\n    EUR = \"EUR\"\n    GBP = \"GBP\"\n    JPY = \"JPY\"\n\n\nclass Asset:\n    \"\"\"\n    Représente un actif financier avec son historique de prix.\n    \n    Pattern de conception : COMPOSITION\n    ───────────────────────────────────\n    Asset POSSÈDE une PriceSeries (relation HAS-A, pas IS-A).\n    \n    D'après 'Python OOP' (Lott & Phillips):\n    \"La composition est généralement le bon choix quand un objet \n    fait partie d'un autre objet.\"\n    \n    Le cycle de vie de PriceSeries est lié à celui de Asset :\n    - Créé quand Asset est créé\n    - Détruit quand Asset est détruit\n    \n    Attributes:\n        ticker: Symbole boursier (ex: 'AAPL')\n        prices: Instance PriceSeries contenant l'historique (COMPOSÉE)\n        sector: Classification sectorielle optionnelle\n        currency: Devise des prix (défaut: USD)\n    \n    Example:\n        >>> ts = PriceSeries([100.0, 105.0, 110.0], \"AAPL_prices\")\n        >>> apple = Asset(\"AAPL\", ts, sector=\"Technology\")\n        >>> apple.volatility\n        0.1587...\n    \"\"\"\n    \n    def __init__(\n        self, \n        ticker: str, \n        prices: PriceSeries,\n        sector: str | None = None,\n        currency: CurrencyEnum = CurrencyEnum.USD\n    ) -> None:\n        \"\"\"\n        Initialise un Asset.\n        \n        Args:\n            ticker: Symbole boursier (ne peut pas être vide)\n            prices: Série de prix (ne peut pas être vide)\n            sector: Secteur d'activité (optionnel)\n            currency: Devise (défaut: USD)\n        \n        Raises:\n            ValueError: Si ticker est vide ou prices est vide\n        \"\"\"\n        # Validation des entrées dans le constructeur\n        if not ticker or not ticker.strip():\n            raise ValueError(\"Le ticker ne peut pas être vide\")\n        if len(prices) == 0:\n            raise ValueError(\"La série de prix ne peut pas être vide\")\n        \n        self.ticker = ticker.upper()  # Normalisation en majuscules\n        self.prices = prices  # Composition : Asset POSSÈDE une PriceSeries\n        self.sector = sector\n        self.currency = currency\n    \n    def __repr__(self) -> str:\n        \"\"\"Représentation pour le développement.\"\"\"\n        return f\"Asset({self.ticker!r}, {len(self.prices)} prices)\"\n    \n    def __str__(self) -> str:\n        \"\"\"Représentation pour l'utilisateur.\"\"\"\n        return f\"{self.ticker}: ${self.current_price:.2f}\"\n\nTest dans le REPL :>>> from pyvest.core.priceseries import PriceSeries\n>>> from pyvest.core.asset import Asset\n>>> ts = PriceSeries([100.0, 105.0, 103.0, 110.0], \"AAPL_prices\")\n>>> apple = Asset(\"AAPL\", ts, sector=\"Technology\")\n>>> apple\nAsset('AAPL', 4 prices)\n>>> apple.ticker\n'AAPL'\n>>> apple.prices.total_return\n0.1","type":"content","url":"/session2#impl-mentation-de-la-classe-asset","position":23},{"hierarchy":{"lvl1":"Session 2 : Composition de Classes et Chargement de Données","lvl3":"Étape 2.2 : Propriétés et délégation vers PriceSeries","lvl2":"Partie 1 : Développement Guidé"},"type":"lvl3","url":"/session2#id-tape-2-2-propri-t-s-et-d-l-gation-vers-priceseries","position":24},{"hierarchy":{"lvl1":"Session 2 : Composition de Classes et Chargement de Données","lvl3":"Étape 2.2 : Propriétés et délégation vers PriceSeries","lvl2":"Partie 1 : Développement Guidé"},"content":"","type":"content","url":"/session2#id-tape-2-2-propri-t-s-et-d-l-gation-vers-priceseries","position":25},{"hierarchy":{"lvl1":"Session 2 : Composition de Classes et Chargement de Données","lvl4":"Le décorateur ","lvl3":"Étape 2.2 : Propriétés et délégation vers PriceSeries","lvl2":"Partie 1 : Développement Guidé"},"type":"lvl4","url":"/session2#le-d-corateur","position":26},{"hierarchy":{"lvl1":"Session 2 : Composition de Classes et Chargement de Données","lvl4":"Le décorateur ","lvl3":"Étape 2.2 : Propriétés et délégation vers PriceSeries","lvl2":"Partie 1 : Développement Guidé"},"content":"Une propriété est un hybride entre un attribut et une méthode. Elle permet d’accéder à une valeur calculée avec la syntaxe d’un attribut (sans parenthèses), tout en exécutant du code derrière.\n\nAvantages des propriétés :\n\nSyntaxe propre : asset.volatility au lieu de asset.get_volatility()\n\nLecture seule par défaut (protection des données)\n\nCalcul à la demande (lazy evaluation)\n\nPossibilité d’ajouter de la validation via un setter# Ajout des propriétés à la classe Asset\n\nclass Asset:\n    # ... (code précédent) ...\n    \n    @property\n    def current_price(self) -> float:\n        \"\"\"Dernier prix connu.\"\"\"\n        return self.prices.values[-1]\n    \n    @property\n    def volatility(self) -> float:\n        \"\"\"Volatilité annualisée (délègue à PriceSeries).\"\"\"\n        return self.prices.annualized_volatility()\n    \n    @property\n    def total_return(self) -> float:\n        \"\"\"Rendement total (délègue à PriceSeries).\"\"\"\n        return self.prices.total_return\n    \n    @property\n    def sharpe_ratio(self) -> float:\n        \"\"\"Ratio de Sharpe (délègue à PriceSeries).\"\"\"\n        return self.prices.sharpe_ratio()\n    \n    @property\n    def max_drawdown(self) -> float:\n        \"\"\"Drawdown maximum (délègue à PriceSeries).\"\"\"\n        return self.prices.max_drawdown()\n\nTest de la délégation :>>> apple = Asset(\"AAPL\", PriceSeries([100.0, 105.0, 110.0], \"AAPL\"))\n>>> apple.volatility        # Délègue à self.prices.annualized_volatility()\n>>> apple.total_return      # Délègue à self.prices.total_return\n0.1","type":"content","url":"/session2#le-d-corateur","position":27},{"hierarchy":{"lvl1":"Session 2 : Composition de Classes et Chargement de Données","lvl4":"Comprendre les décorateurs","lvl3":"Étape 2.2 : Propriétés et délégation vers PriceSeries","lvl2":"Partie 1 : Développement Guidé"},"type":"lvl4","url":"/session2#comprendre-les-d-corateurs","position":28},{"hierarchy":{"lvl1":"Session 2 : Composition de Classes et Chargement de Données","lvl4":"Comprendre les décorateurs","lvl3":"Étape 2.2 : Propriétés et délégation vers PriceSeries","lvl2":"Partie 1 : Développement Guidé"},"content":"Un décorateur est une fonction qui prend une autre fonction en argument et retourne une version modifiée de celle-ci. La syntaxe @decorator est un sucre syntaxique :@decorator\ndef ma_fonction():\n    print(\"Ceci est ma fonction\")\n\n# Est équivalent à :\ndef ma_fonction():\n    print(\"Ceci est ma fonction\")\nma_fonction = decorator(ma_fonction)\n\nPoints clés :\n\nExécution à l’import : Le décorateur s’exécute quand le module est chargé, pas quand la fonction est appelée\n\nClosure : La fonction interne du décorateur a accès aux variables de la fonction externe (scope nonlocal)\n\nPréservation des métadonnées : Utiliser @functools.wraps pour conserver __name__ et __doc__\n\nExemple : décorateur de chronométrageimport time\nimport functools\n\ndef chronometre(func):\n    \"\"\"Décorateur qui mesure le temps d'exécution d'une fonction.\"\"\"\n    @functools.wraps(func)  # Préserve __name__ et __doc__\n    def wrapper(*args, **kwargs):\n        debut = time.perf_counter()\n        resultat = func(*args, **kwargs)\n        duree = time.perf_counter() - debut\n        print(f\"[{duree:.4f}s] {func.__name__}\")\n        return resultat\n    return wrapper\n\n@chronometre\ndef calcul_lent():\n    time.sleep(1)\n    return 42\n\n>>> calcul_lent()\n[1.0012s] calcul_lent\n42","type":"content","url":"/session2#comprendre-les-d-corateurs","position":29},{"hierarchy":{"lvl1":"Session 2 : Composition de Classes et Chargement de Données","lvl3":"Étape 2.3 : Méthode de corrélation entre actifs","lvl2":"Partie 1 : Développement Guidé"},"type":"lvl3","url":"/session2#id-tape-2-3-m-thode-de-corr-lation-entre-actifs","position":30},{"hierarchy":{"lvl1":"Session 2 : Composition de Classes et Chargement de Données","lvl3":"Étape 2.3 : Méthode de corrélation entre actifs","lvl2":"Partie 1 : Développement Guidé"},"content":"","type":"content","url":"/session2#id-tape-2-3-m-thode-de-corr-lation-entre-actifs","position":31},{"hierarchy":{"lvl1":"Session 2 : Composition de Classes et Chargement de Données","lvl4":"Contexte en finance quantitative","lvl3":"Étape 2.3 : Méthode de corrélation entre actifs","lvl2":"Partie 1 : Développement Guidé"},"type":"lvl4","url":"/session2#contexte-en-finance-quantitative","position":32},{"hierarchy":{"lvl1":"Session 2 : Composition de Classes et Chargement de Données","lvl4":"Contexte en finance quantitative","lvl3":"Étape 2.3 : Méthode de corrélation entre actifs","lvl2":"Partie 1 : Développement Guidé"},"content":"La corrélation est une mesure fondamentale en finance quantitative. D’après Portfolio Optimization: Theory and Application (Palomar, 2025) :\n\n“Il existe une structure le long de la dimension des actifs (également appelée structure transversale). Cela signifie que plutôt que de considérer les actifs un par un de manière indépendante, ils doivent être modélisés conjointement. C’est particulièrement important pour évaluer le risque d’un portefeuille, car différentes actions peuvent avoir différentes corrélations.”\n\nEt d’après The Elements of Quantitative Investing (Paleologo) :\n\n“Les rendements ont généralement une corrélation positive car les actifs tendent à évoluer ensemble avec le marché.”\n\nLa corrélation de Pearson mesure la relation linéaire entre deux variables. Pour deux actifs, nous calculons la corrélation de leurs log-rendements.\n\nFormule de Pearson :\\rho_{X,Y} = \\frac{\\text{Cov}(X, Y)}{\\sigma_X \\cdot \\sigma_Y} = \\frac{\\sum_{i=1}^{n} (x_i - \\bar{x})(y_i - \\bar{y})}{\\sqrt{\\sum_{i=1}^{n} (x_i - \\bar{x})^2} \\cdot \\sqrt{\\sum_{i=1}^{n} (y_i - \\bar{y})^2}}\n\nInterprétation :\n\nρ = +1 : Corrélation positive parfaite (les actifs bougent ensemble)\n\nρ = 0 : Pas de corrélation linéaire\n\nρ = -1 : Corrélation négative parfaite (les actifs bougent en sens opposé)import numpy as np\n\nclass Asset:\n    # ... (code précédent) ...\n    \n    def correlation_with(self, other: \"Asset\") -> float:\n        \"\"\"\n        Calcule la corrélation de Pearson des log-rendements avec un autre actif.\n        \n        La corrélation mesure la relation linéaire entre deux séries.\n        En finance, elle est cruciale pour :\n        - Évaluer les bénéfices de diversification\n        - Construire des portefeuilles optimaux\n        - Identifier les paires de trading\n        \n        Args:\n            other: Un autre Asset avec lequel calculer la corrélation\n        \n        Returns:\n            Coefficient de corrélation entre -1 et 1\n        \n        Raises:\n            ValueError: Si les séries ont moins de 2 observations communes\n                        ou si une série a une variance nulle\n        \n        Note:\n            Les séries sont alignées sur la longueur minimale.\n            En production, on alignerait plutôt sur les dates.\n        \"\"\"\n        # Récupération des log-rendements\n        x = np.array(self.prices.all_log_returns())\n        y = np.array(other.prices.all_log_returns())\n        \n        # Alignement des longueurs (gestion des séries de tailles différentes)\n        n = min(len(x), len(y))\n        if n < 2:\n            raise ValueError(\n                f\"Pas assez d'observations communes: {n}. \"\n                \"Minimum requis: 2.\"\n            )\n        \n        x = x[:n]\n        y = y[:n]\n        \n        # Centrage des valeurs (soustraction de la moyenne)\n        x_centered = x - np.mean(x)\n        y_centered = y - np.mean(y)\n        \n        # Covariance (numérateur)\n        covariance = np.dot(x_centered, y_centered)\n        \n        # Variances pour le dénominateur\n        var_x = np.dot(x_centered, x_centered)\n        var_y = np.dot(y_centered, y_centered)\n        \n        # Vérification de la variance nulle\n        if var_x == 0 or var_y == 0:\n            raise ValueError(\n                \"Variance nulle détectée. \"\n                \"La corrélation n'est pas définie pour une série constante.\"\n            )\n        \n        # Formule de Pearson : cov(x,y) / (std(x) * std(y))\n        return covariance / np.sqrt(var_x * var_y)\n\n⚠️ Note de correction : La version originale retournait 0.0 silencieusement en cas de variance nulle ou de données insuffisantes. C’est problématique car une corrélation de 0 a une signification réelle (absence de relation linéaire). La version corrigée lève une ValueError explicite pour éviter les erreurs silencieuses.","type":"content","url":"/session2#contexte-en-finance-quantitative","position":33},{"hierarchy":{"lvl1":"Session 2 : Composition de Classes et Chargement de Données","lvl3":"Étape 2.4 : Git Commit","lvl2":"Partie 1 : Développement Guidé"},"type":"lvl3","url":"/session2#id-tape-2-4-git-commit","position":34},{"hierarchy":{"lvl1":"Session 2 : Composition de Classes et Chargement de Données","lvl3":"Étape 2.4 : Git Commit","lvl2":"Partie 1 : Développement Guidé"},"content":"git add pyvest/core/asset.py\ngit commit -m \"feat(core): add Asset class with composition over PriceSeries\"","type":"content","url":"/session2#id-tape-2-4-git-commit","position":35},{"hierarchy":{"lvl1":"Session 2 : Composition de Classes et Chargement de Données","lvl3":"Étape 3 : DataLoader avec système de cache intelligent","lvl2":"Partie 1 : Développement Guidé"},"type":"lvl3","url":"/session2#id-tape-3-dataloader-avec-syst-me-de-cache-intelligent","position":36},{"hierarchy":{"lvl1":"Session 2 : Composition de Classes et Chargement de Données","lvl3":"Étape 3 : DataLoader avec système de cache intelligent","lvl2":"Partie 1 : Développement Guidé"},"content":"","type":"content","url":"/session2#id-tape-3-dataloader-avec-syst-me-de-cache-intelligent","position":37},{"hierarchy":{"lvl1":"Session 2 : Composition de Classes et Chargement de Données","lvl4":"Installation de yfinance","lvl3":"Étape 3 : DataLoader avec système de cache intelligent","lvl2":"Partie 1 : Développement Guidé"},"type":"lvl4","url":"/session2#installation-de-yfinance","position":38},{"hierarchy":{"lvl1":"Session 2 : Composition de Classes et Chargement de Données","lvl4":"Installation de yfinance","lvl3":"Étape 3 : DataLoader avec système de cache intelligent","lvl2":"Partie 1 : Développement Guidé"},"content":"# Dans le terminal :\nuv add yfinance\n\n# Test dans le REPL :\n>>> import yfinance as yf\n>>> msft = yf.Ticker(\"MSFT\")\n>>> msft.info['shortName']\n'Microsoft Corporation'\n\nyfinance est une librairie open-source non officielle qui simplifie l’accès à l’API Yahoo Finance. Elle supporte les prix historiques, les données fondamentales et les données d’options.\n\n⚠️ Avertissement légal : yfinance ≠ permission d’utiliser les données Yahoo comme bon vous semble. Pour tout usage au-delà de la recherche personnelle légère, obtenez une licence appropriée.","type":"content","url":"/session2#installation-de-yfinance","position":39},{"hierarchy":{"lvl1":"Session 2 : Composition de Classes et Chargement de Données","lvl4":"Conception de l’interface du DataLoader","lvl3":"Étape 3 : DataLoader avec système de cache intelligent","lvl2":"Partie 1 : Développement Guidé"},"type":"lvl4","url":"/session2#conception-de-linterface-du-dataloader","position":40},{"hierarchy":{"lvl1":"Session 2 : Composition de Classes et Chargement de Données","lvl4":"Conception de l’interface du DataLoader","lvl3":"Étape 3 : DataLoader avec système de cache intelligent","lvl2":"Partie 1 : Développement Guidé"},"content":"Interface publique :\n├── fetch_single_ticker(ticker, price_col, dates) -> PriceSeries\n├── fetch_multiple_tickers(tickers, price_col, dates) -> dict[str, PriceSeries]\n└── clear_cache() -> int\n\nInterface privée :\n├── _get_cache_path(ticker, price_col, dates) -> Path\n├── _check_date_overlap(...) -> tuple[str, Timestamp, Timestamp]\n├── _load_from_cache(...) -> tuple[DataFrame, str, tuple]\n└── _save_to_cache(...) -> None\n\nPourquoi un système de cache intelligent ?\n\nRaison\n\nExplication\n\nPerformance\n\nÉviter les appels API redondants, chargement local rapide\n\nRate limiting\n\nLes APIs ont souvent des limites de requêtes\n\nReproductibilité\n\nGarantir l’utilisation du même dataset en recherche\n\nMode hors-ligne\n\nTravailler sans connexion internet\n\nÉconomie de bande passante\n\nNe télécharger que les données manquantes","type":"content","url":"/session2#conception-de-linterface-du-dataloader","position":41},{"hierarchy":{"lvl1":"Session 2 : Composition de Classes et Chargement de Données","lvl4":"Architecture du cache avec gestion des chevauchements","lvl3":"Étape 3 : DataLoader avec système de cache intelligent","lvl2":"Partie 1 : Développement Guidé"},"type":"lvl4","url":"/session2#architecture-du-cache-avec-gestion-des-chevauchements","position":42},{"hierarchy":{"lvl1":"Session 2 : Composition de Classes et Chargement de Données","lvl4":"Architecture du cache avec gestion des chevauchements","lvl3":"Étape 3 : DataLoader avec système de cache intelligent","lvl2":"Partie 1 : Développement Guidé"},"content":"Le système de cache gère quatre scénarios de correspondance temporelle :Cas 1: EXACT - La requête correspond exactement au cache\nCache:    |-------------|\nRequête:  |-------------|\n→ Retourner directement les données en cache\n\nCas 2: CONTAINS - Le cache contient la période demandée\nCache:    |-----------------|\nRequête:      |---------|\n→ Découper (slice) les données en cache\n\nCas 3: OVERLAP_AFTER - Chevauchement à droite\nCache:    |---------|\nRequête:      |-----------|\n→ Fusionner cache + nouvelles données à droite\n\nCas 4: OVERLAP_BEFORE - Chevauchement à gauche\nCache:          |---------|\nRequête:   |-----------|\n→ Fusionner nouvelles données à gauche + cache\n\nCas 5: MISS - Aucun chevauchement\nCache:    |-----|\nRequête:              |-----|\n→ Télécharger toutes les données","type":"content","url":"/session2#architecture-du-cache-avec-gestion-des-chevauchements","position":43},{"hierarchy":{"lvl1":"Session 2 : Composition de Classes et Chargement de Données","lvl4":"Implémentation du DataLoader","lvl3":"Étape 3 : DataLoader avec système de cache intelligent","lvl2":"Partie 1 : Développement Guidé"},"type":"lvl4","url":"/session2#impl-mentation-du-dataloader","position":44},{"hierarchy":{"lvl1":"Session 2 : Composition de Classes et Chargement de Données","lvl4":"Implémentation du DataLoader","lvl3":"Étape 3 : DataLoader avec système de cache intelligent","lvl2":"Partie 1 : Développement Guidé"},"content":"# Fichier: pyvest/data/loader.py\n\nfrom pathlib import Path\nfrom datetime import datetime\nimport logging\nimport pickle\nfrom typing import Sequence\n\nimport yfinance as yf\nimport pandas as pd\n\nfrom pyvest.core.priceseries import PriceSeries\n\n\nclass DataLoader:\n    \"\"\"\n    Charge des données de marché depuis Yahoo Finance avec mise en cache intelligente.\n    \n    Le système de cache gère cinq scénarios de correspondance temporelle :\n    1. EXACT : La requête correspond exactement aux données en cache\n    2. CONTAINS : La requête est un sous-ensemble du cache\n    3. OVERLAP_AFTER : Intersection partielle, fetch complémentaire à droite\n    4. OVERLAP_BEFORE : Intersection partielle, fetch complémentaire à gauche\n    5. MISS : Aucune donnée en cache, fetch complet nécessaire\n    \n    Attributes:\n        cache_dir: Répertoire de stockage du cache\n        logger: Logger pour le suivi des opérations\n    \n    Example:\n        >>> loader = DataLoader(cache_dir=\".cache\")\n        >>> ts = loader.fetch_single_ticker(\"AAPL\", \"Close\", (\"2024-01-01\", \"2024-06-01\"))\n        >>> len(ts)\n        125\n    \"\"\"\n    \n    def __init__(self, cache_dir: str = \".cache\") -> None:\n        \"\"\"\n        Initialise le DataLoader.\n        \n        Args:\n            cache_dir: Chemin du répertoire de cache (créé si inexistant)\n        \"\"\"\n        self.cache_dir = Path(cache_dir)\n        self.cache_dir.mkdir(exist_ok=True)\n        self.logger = logging.getLogger(self.__class__.__name__)\n\n    def _get_cache_path(\n        self, \n        ticker: str, \n        price_col: str, \n        dates: tuple[str, str]\n    ) -> Path:\n        \"\"\"\n        Génère le chemin du fichier cache pour une requête donnée.\n        \n        Format: {ticker}_{price_col}_{start}_{end}.pkl\n        \"\"\"\n        return self.cache_dir / f\"{ticker}_{price_col}_{dates[0]}_{dates[1]}.pkl\"\n\n    def _check_date_overlap(\n        self,\n        cached_start: pd.Timestamp,\n        cached_end: pd.Timestamp,\n        req_start: pd.Timestamp,\n        req_end: pd.Timestamp\n    ) -> tuple[str, pd.Timestamp | None, pd.Timestamp | None]:\n        \"\"\"\n        Détermine le type de chevauchement entre le cache et la requête.\n        \n        Args:\n            cached_start: Date de début des données en cache\n            cached_end: Date de fin des données en cache\n            req_start: Date de début de la requête\n            req_end: Date de fin de la requête\n        \n        Returns:\n            tuple: (status, gap_start, gap_end)\n            - status: \"exact\" | \"contains\" | \"overlap_before\" | \"overlap_after\" | \"miss\"\n            - gap_start: Début de la période manquante (si overlap)\n            - gap_end: Fin de la période manquante (si overlap)\n        \"\"\"\n        # Cas MISS: Aucune intersection\n        if cached_end < req_start or cached_start > req_end:\n            return (\"miss\", None, None)\n\n        # Cas EXACT: Correspondance parfaite\n        if cached_start == req_start and cached_end == req_end:\n            return (\"exact\", None, None)\n\n        # Cas CONTAINS: Le cache englobe la requête\n        if cached_start <= req_start and cached_end >= req_end:\n            return (\"contains\", None, None)\n\n        # Cas OVERLAP_AFTER: Le cache commence avant/au début mais finit avant la fin\n        if cached_start <= req_start and cached_end < req_end:\n            gap_start = cached_end + pd.Timedelta(days=1)\n            gap_end = req_end\n            return (\"overlap_after\", gap_start, gap_end)\n\n        # Cas OVERLAP_BEFORE: Le cache commence après le début mais finit après/à la fin\n        if cached_start > req_start and cached_end >= req_end:\n            gap_start = req_start\n            gap_end = cached_start - pd.Timedelta(days=1)\n            return (\"overlap_before\", gap_start, gap_end)\n\n        # Cas non couvert (le cache est un sous-ensemble strict de la requête)\n        # Traité comme MISS pour simplicité - on refetch tout\n        return (\"miss\", None, None)\n\n    def _load_from_cache(\n        self,\n        ticker: str,\n        price_col: str,\n        start_date: pd.Timestamp,\n        end_date: pd.Timestamp\n    ) -> tuple[pd.DataFrame | None, str, tuple | None]:\n        \"\"\"\n        Recherche et charge les données disponibles en cache.\n        \n        Parcourt les fichiers du répertoire cache pour trouver une correspondance\n        avec le couple (ticker, price_col) et détermine le type de chevauchement.\n        \n        Args:\n            ticker: Symbole boursier\n            price_col: Nom de la colonne prix ('Close', 'Open', etc.)\n            start_date: Date de début de la requête\n            end_date: Date de fin de la requête\n        \n        Returns:\n            tuple: (dataframe, status, gap_range)\n            - dataframe: Données en cache ou None\n            - status: Type de correspondance\n            - gap_range: (gap_start, gap_end) si overlap, sinon None\n        \"\"\"\n        if not self.cache_dir.exists():\n            return (None, \"miss\", None)\n\n        # Itération sur les fichiers du cache pour match (ticker, price_col)\n        for file_path in self.cache_dir.iterdir():\n            if not file_path.is_file() or file_path.suffix != '.pkl':\n                continue\n\n            try:\n                # Parse le nom du fichier: ticker_pricecol_startdate_enddate.pkl\n                name_parts = file_path.stem.split('_')\n                \n                # Vérification du format attendu (4 parties minimum)\n                if len(name_parts) < 4:\n                    continue\n                \n                cached_ticker = name_parts[0]\n                cached_col = name_parts[1]\n                cached_start_str = name_parts[2]\n                cached_end_str = name_parts[3]\n\n                # Vérifier la correspondance ticker et price_col\n                if cached_ticker != ticker or cached_col != price_col:\n                    continue\n\n                # Parser les dates\n                cached_start = pd.to_datetime(cached_start_str)\n                cached_end = pd.to_datetime(cached_end_str)\n\n                # Déterminer le type de chevauchement\n                status, gap_start, gap_end = self._check_date_overlap(\n                    cached_start, cached_end, start_date, end_date\n                )\n\n                # Charger les données si le statut n'est pas 'miss'\n                if status != \"miss\":\n                    with open(file_path, 'rb') as f:\n                        data = pickle.load(f)\n\n                    # Reconstruire le DataFrame avec les dates\n                    prices_list = data['prices']\n                    dates_list = data.get('dates')  # Nouveau: stocker les dates réelles\n                    \n                    df = pd.DataFrame({price_col: prices_list})\n                    \n                    if dates_list is not None:\n                        # Utiliser les dates réelles stockées\n                        df.index = pd.to_datetime(dates_list)\n                    else:\n                        # Fallback: utiliser les jours ouvrés (moins précis)\n                        date_range = pd.bdate_range(\n                            start=cached_start, \n                            periods=len(df)\n                        )\n                        df.index = date_range\n\n                    if status == \"exact\":\n                        return (df, \"exact\", None)\n                    elif status == \"contains\":\n                        return (df, \"contains\", None)\n                    elif status.startswith(\"overlap\"):\n                        return (df, status, (gap_start, gap_end))\n\n            except (ValueError, KeyError, pickle.UnpicklingError) as e:\n                # Ignorer les fichiers cache corrompus\n                self.logger.warning(f\"Fichier cache corrompu {file_path}: {e}\")\n                continue\n\n        return (None, \"miss\", None)\n    \n    def _save_to_cache(\n        self, \n        cache_path: Path, \n        prices: list[float],\n        dates: list,\n        ticker: str, \n        start: str, \n        end: str\n    ) -> None:\n        \"\"\"\n        Sauvegarde les prix dans un fichier cache avec métadonnées.\n        \n        Args:\n            cache_path: Chemin du fichier cache\n            prices: Liste des prix\n            dates: Liste des dates correspondantes (index du DataFrame)\n            ticker: Symbole boursier\n            start: Date de début (string)\n            end: Date de fin (string)\n        \"\"\"\n        data = {\n            \"ticker\": ticker,\n            \"start\": start,\n            \"end\": end,\n            \"fetched_at\": datetime.now().isoformat(),\n            \"n_prices\": len(prices),\n            \"prices\": prices,\n            \"dates\": dates  # Stocker les dates réelles pour reconstruction précise\n        }\n        with open(cache_path, 'wb') as f:\n            pickle.dump(data, f)\n        self.logger.debug(f\"Cache sauvegardé: {cache_path}\")\n    \n    def fetch_single_ticker(\n        self, \n        ticker: str, \n        price_col: str, \n        dates: tuple[str, str]\n    ) -> PriceSeries | None:\n        \"\"\"\n        Récupère les données de prix d'un ticker unique avec système de cache.\n        \n        Gère automatiquement les 5 cas de correspondance temporelle avec le cache.\n        \n        Args:\n            ticker: Symbole boursier (ex: 'AAPL')\n            price_col: Nom de la colonne prix (ex: 'Close', 'Open')\n            dates: Tuple (start_date, end_date) au format 'YYYY-MM-DD'\n        \n        Returns:\n            Instance de PriceSeries ou None si échec\n        \n        Example:\n            >>> loader = DataLoader()\n            >>> ts = loader.fetch_single_ticker(\"AAPL\", \"Close\", (\"2024-01-01\", \"2024-06-01\"))\n        \"\"\"\n        # Conversion des dates en Timestamp\n        start_date = pd.to_datetime(dates[0], format=\"%Y-%m-%d\")\n        end_date = pd.to_datetime(dates[1], format=\"%Y-%m-%d\")\n\n        self.logger.info(f\"Fetching {ticker} {price_col} from {dates[0]} to {dates[1]}\")\n\n        # Vérifier le cache\n        cached_df, status, gap_range = self._load_from_cache(\n            ticker, price_col, start_date, end_date\n        )\n\n        if status == \"exact\":\n            self.logger.info(f\"Cache HIT (exact): {ticker}\")\n            prices = cached_df[price_col].tolist()\n            return PriceSeries(values=prices, name=price_col)\n\n        elif status == \"contains\":\n            self.logger.info(f\"Cache HIT (slicing): {ticker}\")\n            # Découper le DataFrame cache pour obtenir le sous-ensemble demandé\n            mask = (cached_df.index >= start_date) & (cached_df.index <= end_date)\n            sliced_df = cached_df[mask]\n            prices = sliced_df[price_col].tolist()\n            return PriceSeries(values=prices, name=price_col)\n\n        elif status.startswith(\"overlap\"):\n            self.logger.info(f\"Cache PARTIAL (extending): {ticker}\")\n            gap_start, gap_end = gap_range\n\n            # Fetch la partie manquante\n            ticker_instance = yf.Ticker(ticker)\n            gap_df = ticker_instance.history(start=gap_start, end=gap_end)\n\n            if gap_df.empty:\n                self.logger.warning(f\"Échec du fetch des données manquantes pour {ticker}\")\n                return None\n\n            # Fusionner le cache avec les nouvelles données\n            if status == \"overlap_after\":\n                # Concaténation à droite\n                merged_df = pd.concat([cached_df[[price_col]], gap_df[[price_col]]])\n            else:\n                # Concaténation à gauche\n                merged_df = pd.concat([gap_df[[price_col]], cached_df[[price_col]]])\n\n            # Supprimer les doublons et trier par date\n            merged_df = merged_df[~merged_df.index.duplicated(keep='first')].sort_index()\n\n            # Sauvegarder le cache étendu\n            cache_path = self._get_cache_path(ticker, price_col, dates)\n            prices_list = merged_df[price_col].tolist()\n            dates_list = merged_df.index.tolist()\n            \n            self._save_to_cache(\n                cache_path=cache_path,\n                prices=prices_list,\n                dates=dates_list,\n                ticker=ticker,\n                start=dates[0],\n                end=dates[1]\n            )\n\n            return PriceSeries(values=prices_list, name=price_col)\n\n        else:  # miss: pas de données en cache correspondantes\n            self.logger.info(f\"Cache MISS: fetching from Yahoo Finance for {ticker}\")\n\n            ticker_instance = yf.Ticker(ticker)\n            df = ticker_instance.history(start=start_date, end=end_date)\n\n            if df.empty:\n                self.logger.warning(f\"DataFrame vide retourné pour {ticker}\")\n                return None\n\n            if price_col not in df.columns:\n                self.logger.error(f\"Colonne '{price_col}' non trouvée dans les données\")\n                raise KeyError(f\"Colonne '{price_col}' non disponible\")\n\n            prices = df[price_col].tolist()\n            dates_list = df.index.tolist()\n\n            if not prices:\n                self.logger.warning(f\"Liste de prix vide pour {ticker}[{price_col}]\")\n                return None\n\n            # Sauvegarder dans le cache\n            cache_path = self._get_cache_path(ticker, price_col, dates)\n            self._save_to_cache(\n                cache_path=cache_path,\n                prices=prices,\n                dates=dates_list,\n                ticker=ticker,\n                start=dates[0],\n                end=dates[1]\n            )\n\n            return PriceSeries(values=prices, name=price_col)\n    \n    def fetch_multiple_tickers(\n        self,\n        tickers: Sequence[str],\n        price_col: str,\n        dates: tuple[str, str]\n    ) -> dict[str, PriceSeries]:\n        \"\"\"\n        Récupère les données de prix pour plusieurs tickers.\n        \n        Args:\n            tickers: Liste de symboles boursiers\n            price_col: Nom de la colonne prix\n            dates: Tuple (start_date, end_date)\n        \n        Returns:\n            Dictionnaire {ticker: PriceSeries}\n            Les tickers en échec sont omis du résultat.\n        \"\"\"\n        results = {}\n        for ticker in tickers:\n            ps = self.fetch_single_ticker(ticker, price_col, dates)\n            if ps is not None:\n                results[ticker] = ps\n        return results\n    \n    def clear_cache(self) -> int:\n        \"\"\"\n        Supprime tous les fichiers du cache.\n        \n        Returns:\n            Nombre de fichiers supprimés\n        \"\"\"\n        count = 0\n        for file in self.cache_dir.glob(\"*.pkl\"):\n            file.unlink()\n            count += 1\n        self.logger.info(f\"Cache vidé: {count} fichiers supprimés\")\n        return count\n\n⚠️ Corrections apportées au système de cache :\n\nStockage des dates réelles : La version originale reconstruisait les dates avec freq='B' (jours ouvrés), ce qui ne correspond pas aux jours de trading réels (ne tient pas compte des jours fériés). La version corrigée stocke les dates réelles du DataFrame yfinance.\n\nGestion robuste du parsing : Ajout d’une vérification du nombre de parties dans le nom de fichier.\n\nCas manquant identifié : Le cas où le cache est un sous-ensemble strict de la requête (cache inclus dans requête) est traité comme MISS pour éviter une logique complexe de double fetch.","type":"content","url":"/session2#impl-mentation-du-dataloader","position":45},{"hierarchy":{"lvl1":"Session 2 : Composition de Classes et Chargement de Données","lvl4":"Test du système de cache","lvl3":"Étape 3 : DataLoader avec système de cache intelligent","lvl2":"Partie 1 : Développement Guidé"},"type":"lvl4","url":"/session2#test-du-syst-me-de-cache","position":46},{"hierarchy":{"lvl1":"Session 2 : Composition de Classes et Chargement de Données","lvl4":"Test du système de cache","lvl3":"Étape 3 : DataLoader avec système de cache intelligent","lvl2":"Partie 1 : Développement Guidé"},"content":"from pyvest.data.loader import DataLoader\nimport time\n\nloader = DataLoader(cache_dir=\".cache\")\n\n# Premier appel : fetch depuis l'API\nstart = time.perf_counter()\nts1 = loader.fetch_single_ticker(\"AAPL\", \"Close\", (\"2024-01-01\", \"2024-06-01\"))\npremier_temps = time.perf_counter() - start\nprint(f\"Premier fetch: {premier_temps:.2f} secondes\")\n\n# Second appel : chargement depuis le cache\nstart = time.perf_counter()\nts2 = loader.fetch_single_ticker(\"AAPL\", \"Close\", (\"2024-01-01\", \"2024-06-01\"))\nsecond_temps = time.perf_counter() - start\nprint(f\"Second fetch: {second_temps:.4f} secondes\")\n\nprint(f\"Accélération: {premier_temps/second_temps:.0f}x plus rapide avec le cache\")\n\n# Test d'extension du cache\nstart = time.perf_counter()\nts3 = loader.fetch_single_ticker(\"AAPL\", \"Close\", (\"2024-01-01\", \"2024-09-01\"))\nextension_temps = time.perf_counter() - start\nprint(f\"Extension du cache: {extension_temps:.2f} secondes\")","type":"content","url":"/session2#test-du-syst-me-de-cache","position":47},{"hierarchy":{"lvl1":"Session 2 : Composition de Classes et Chargement de Données","lvl3":"Étape 4 : Collections Python","lvl2":"Partie 1 : Développement Guidé"},"type":"lvl3","url":"/session2#id-tape-4-collections-python","position":48},{"hierarchy":{"lvl1":"Session 2 : Composition de Classes et Chargement de Données","lvl3":"Étape 4 : Collections Python","lvl2":"Partie 1 : Développement Guidé"},"content":"","type":"content","url":"/session2#id-tape-4-collections-python","position":49},{"hierarchy":{"lvl1":"Session 2 : Composition de Classes et Chargement de Données","lvl4":"Les listes : collections ordonnées","lvl3":"Étape 4 : Collections Python","lvl2":"Partie 1 : Développement Guidé"},"type":"lvl4","url":"/session2#les-listes-collections-ordonn-es","position":50},{"hierarchy":{"lvl1":"Session 2 : Composition de Classes et Chargement de Données","lvl4":"Les listes : collections ordonnées","lvl3":"Étape 4 : Collections Python","lvl2":"Partie 1 : Développement Guidé"},"content":"D’après Fluent Python (Ramalho) :\n\n“Une liste en Python est une séquence mutable d’objets arbitraires.”\n\nLes listes sont la collection de base en Python. Elles maintiennent l’ordre d’insertion, supportent l’indexation et le slicing, et peuvent contenir n’importe quel type d’objet.\n\nCaractéristiques principales :\n\nPropriété\n\nDescription\n\nMutable\n\nOn peut ajouter, supprimer ou modifier des éléments\n\nOrdonnée\n\nL’ordre d’insertion est préservé\n\nIndexable\n\nAccès par position [i] et slicing [a:b]\n\nHétérogène\n\nPeut contenir des types différents# Opérations courantes sur les listes\nassets = [apple, msft, google, amazon]\n\n# Accès par index\npremier = assets[0]           # Premier élément\ndernier = assets[-1]          # Dernier élément\nsous_liste = assets[1:3]      # Éléments aux indices 1 et 2\n\n# Modification\nassets.append(nvidia)         # Ajout en fin\nassets.insert(0, tesla)       # Insertion à une position\nassets.remove(msft)           # Suppression par valeur\nelement = assets.pop()        # Suppression et retour du dernier\n\n# Itération\nfor asset in assets:\n    print(f\"{asset.ticker}: {asset.volatility:.2%}\")\n\n# Recherche\nif apple in assets:\n    print(\"Apple est dans la liste\")","type":"content","url":"/session2#les-listes-collections-ordonn-es","position":51},{"hierarchy":{"lvl1":"Session 2 : Composition de Classes et Chargement de Données","lvl4":"Syntaxe des compréhensions","lvl3":"Étape 4 : Collections Python","lvl2":"Partie 1 : Développement Guidé"},"type":"lvl4","url":"/session2#syntaxe-des-compr-hensions","position":52},{"hierarchy":{"lvl1":"Session 2 : Composition de Classes et Chargement de Données","lvl4":"Syntaxe des compréhensions","lvl3":"Étape 4 : Collections Python","lvl2":"Partie 1 : Développement Guidé"},"content":"D’après Fluent Python :\n\n“Une compréhension de liste est plus explicite. Son but est toujours de construire une nouvelle liste.”\n\nLes compréhensions offrent une syntaxe concise pour créer des collections à partir d’itérables existants.\n\nAnatomie d’une compréhension :[expression for element in iterable if condition]\n ↑           ↑                       ↑\n sortie      boucle                  filtre optionnel\n\nExemples pratiques :# Extraction des tickers\ntickers = [asset.ticker for asset in assets]\n\n# Tuples (ticker, rendement)\nperformance = [(a.ticker, a.total_return) for a in assets]\n\n# Filtrage : actifs avec rendement positif\ngagnants = [a for a in assets if a.total_return > 0]\n\n# Filtrage : haute volatilité (> 25%)\nhaute_vol = [a.ticker for a in assets if a.volatility > 0.25]\n\n# Tri par rendement (décroissant)\ntries = sorted(assets, key=lambda a: a.total_return, reverse=True)\n\nExpressions génératrices : Utilisent des parenthèses au lieu de crochets et produisent les éléments paresseusement (un à la fois), économisant la mémoire :# Générateur : ne crée pas de liste en mémoire\ntotal_vol = sum(a.volatility for a in assets)\n\n# Comparaison de l'utilisation mémoire :\nsum([a.volatility for a in assets])  # Crée une liste intermédiaire\nsum(a.volatility for a in assets)    # Pas de liste intermédiaire (lazy)","type":"content","url":"/session2#syntaxe-des-compr-hensions","position":53},{"hierarchy":{"lvl1":"Session 2 : Composition de Classes et Chargement de Données","lvl4":"Les dictionnaires : mapping clé-valeur","lvl3":"Étape 4 : Collections Python","lvl2":"Partie 1 : Développement Guidé"},"type":"lvl4","url":"/session2#les-dictionnaires-mapping-cl-valeur","position":54},{"hierarchy":{"lvl1":"Session 2 : Composition de Classes et Chargement de Données","lvl4":"Les dictionnaires : mapping clé-valeur","lvl3":"Étape 4 : Collections Python","lvl2":"Partie 1 : Développement Guidé"},"content":"D’après Fluent Python :\n\n“Le type dict est une brique fondamentale de Python.”\n\nLes dictionnaires offrent une recherche en O(1) par clé, ce qui les rend essentiels pour un accès rapide aux données.\n\nCaractéristiques principales :\n\nPropriété\n\nDescription\n\nClés uniques\n\nChaque clé apparaît une seule fois\n\nClés hashables\n\nLes clés doivent être immutables (str, int, tuple)\n\nRecherche O(1)\n\nAccès quasi-instantané par clé\n\nOrdre préservé\n\nDepuis Python 3.7, l’ordre d’insertion est garanti# Création par compréhension : table de correspondance ticker → asset\nassets_par_ticker = {asset.ticker: asset for asset in assets}\n\n# Recherche rapide O(1)\napple = assets_par_ticker[\"AAPL\"]\nnvidia = assets_par_ticker.get(\"NVDA\")  # Sûr : retourne None si absent\n\n# Vérification d'existence\nif \"TSLA\" in assets_par_ticker:\n    tesla = assets_par_ticker[\"TSLA\"]\n\n# Itération sur les paires clé-valeur\nfor ticker, asset in assets_par_ticker.items():\n    print(f\"{ticker}: ${asset.current_price:.2f}\")","type":"content","url":"/session2#les-dictionnaires-mapping-cl-valeur","position":55},{"hierarchy":{"lvl1":"Session 2 : Composition de Classes et Chargement de Données","lvl4":"Les ensembles : collections uniques","lvl3":"Étape 4 : Collections Python","lvl2":"Partie 1 : Développement Guidé"},"type":"lvl4","url":"/session2#les-ensembles-collections-uniques","position":56},{"hierarchy":{"lvl1":"Session 2 : Composition de Classes et Chargement de Données","lvl4":"Les ensembles : collections uniques","lvl3":"Étape 4 : Collections Python","lvl2":"Partie 1 : Développement Guidé"},"content":"D’après Fluent Python :\n\n“Un ensemble est une collection d’objets uniques.”\n\nLes ensembles excellent pour le test d’appartenance (O(1) vs O(n) pour les listes) et les opérations ensemblistes.# Comparaison de portefeuilles avec opérations ensemblistes\nmon_portefeuille = {\"AAPL\", \"MSFT\", \"GOOGL\"}\nbenchmark = {\"AAPL\", \"MSFT\", \"AMZN\", \"NVDA\", \"META\"}\n\n# Intersection : présent dans les deux\ncommun = mon_portefeuille & benchmark  # {'AAPL', 'MSFT'}\n\n# Différence : dans le benchmark mais pas dans mon portefeuille\nmanquant = benchmark - mon_portefeuille  # {'AMZN', 'NVDA', 'META'}\n\n# Test d'appartenance rapide O(1)\n\"AAPL\" in mon_portefeuille  # True (instantané)","type":"content","url":"/session2#les-ensembles-collections-uniques","position":57},{"hierarchy":{"lvl1":"Session 2 : Composition de Classes et Chargement de Données","lvl2":"Partie 2 : Exercices Pratiques"},"type":"lvl2","url":"/session2#partie-2-exercices-pratiques","position":58},{"hierarchy":{"lvl1":"Session 2 : Composition de Classes et Chargement de Données","lvl2":"Partie 2 : Exercices Pratiques"},"content":"","type":"content","url":"/session2#partie-2-exercices-pratiques","position":59},{"hierarchy":{"lvl1":"Session 2 : Composition de Classes et Chargement de Données","lvl3":"Exercice 1 : La classe Universe (25 min)","lvl2":"Partie 2 : Exercices Pratiques"},"type":"lvl3","url":"/session2#exercice-1-la-classe-universe-25-min","position":60},{"hierarchy":{"lvl1":"Session 2 : Composition de Classes et Chargement de Données","lvl3":"Exercice 1 : La classe Universe (25 min)","lvl2":"Partie 2 : Exercices Pratiques"},"content":"Objectif : Créer une classe Universe pour gérer une collection d’actifs avec le pattern d’agrégation.# Fichier: pyvest/core/universe.py\n\nfrom pyvest.core.asset import Asset\nfrom typing import Iterator\n\n\nclass Universe:\n    \"\"\"\n    Collection d'actifs représentant un univers d'investissement.\n    \n    Pattern de conception : AGRÉGATION\n    ──────────────────────────────────\n    Universe CONTIENT des Asset, mais les Asset peuvent exister \n    indépendamment de l'Universe.\n    \n    La classe implémente le protocole d'itération (__iter__) et\n    de conteneur (__contains__, __len__) pour une utilisation\n    pythonique.\n    \"\"\"\n    \n    def __init__(self, assets: list[Asset] | None = None) -> None:\n        self._assets: dict[str, Asset] = {}\n        if assets:\n            for asset in assets:\n                self.add(asset)\n    \n    def add(self, asset: Asset) -> None:\n        \"\"\"Ajoute un actif à l'univers.\"\"\"\n        # Votre code ici\n        pass\n    \n    def get(self, ticker: str) -> Asset | None:\n        \"\"\"Récupère un actif par son ticker.\"\"\"\n        # Votre code ici\n        pass\n    \n    def remove(self, ticker: str) -> Asset | None:\n        \"\"\"Retire un actif de l'univers.\"\"\"\n        # Votre code ici\n        pass\n    \n    def __len__(self) -> int:\n        # Votre code ici\n        pass\n    \n    def __iter__(self) -> Iterator[Asset]:\n        # Votre code ici\n        pass\n    \n    def __contains__(self, ticker: str) -> bool:\n        # Votre code ici\n        pass\n    \n    @property\n    def tickers(self) -> list[str]:\n        # Votre code ici\n        pass\n    \n    def filter_by_sector(self, sector: str) -> list[Asset]:\n        \"\"\"Filtre les actifs par secteur. Utilisez une compréhension !\"\"\"\n        # Votre code ici\n        pass","type":"content","url":"/session2#exercice-1-la-classe-universe-25-min","position":61},{"hierarchy":{"lvl1":"Session 2 : Composition de Classes et Chargement de Données","lvl3":"Exercice 2 : Top K Corrélations (30 min)","lvl2":"Partie 2 : Exercices Pratiques"},"type":"lvl3","url":"/session2#exercice-2-top-k-corr-lations-30-min","position":62},{"hierarchy":{"lvl1":"Session 2 : Composition de Classes et Chargement de Données","lvl3":"Exercice 2 : Top K Corrélations (30 min)","lvl2":"Partie 2 : Exercices Pratiques"},"content":"Objectif : Implémenter une fonction qui extrait les K paires d’actifs les plus corrélées d’un univers.","type":"content","url":"/session2#exercice-2-top-k-corr-lations-30-min","position":63},{"hierarchy":{"lvl1":"Session 2 : Composition de Classes et Chargement de Données","lvl4":"Contexte en finance quantitative","lvl3":"Exercice 2 : Top K Corrélations (30 min)","lvl2":"Partie 2 : Exercices Pratiques"},"type":"lvl4","url":"/session2#contexte-en-finance-quantitative-1","position":64},{"hierarchy":{"lvl1":"Session 2 : Composition de Classes et Chargement de Données","lvl4":"Contexte en finance quantitative","lvl3":"Exercice 2 : Top K Corrélations (30 min)","lvl2":"Partie 2 : Exercices Pratiques"},"content":"L’extraction des paires les plus corrélées est une analyse fondamentale en finance quantitative. D’après Portfolio Optimization (Palomar, 2025) :\n\n“La diversification d’un investissement en allouant du capital à plusieurs actifs peut ne pas aider à réduire le risque si ces actifs sont fortement corrélés.”\n\nApplications pratiques de l’analyse des top-K corrélations :\n\nApplication\n\nDescription\n\nDétection de risque de concentration\n\nIdentifier les paires très corrélées qui augmentent le risque systémique\n\nPairs trading\n\nTrouver des paires d’actifs co-intégrés pour des stratégies de mean-reversion\n\nConstruction de portefeuille\n\nÉviter la sur-représentation de facteurs cachés\n\nMonitoring de régime\n\nSuivre l’évolution des corrélations dans le temps\n\nStress testing\n\nIdentifier les liens qui pourraient amplifier les pertes en période de crise\n\nNote pédagogique : Cette fonction sera remplacée par une version vectorisée plus performante dans la Session 3 (Universe.top_correlations()), mais l’implémentation avec boucles permet de bien comprendre l’algorithme sous-jacent.\n\nRéférence méthodologique : Cette analyse est inspirée du projet “Global Multi-Asset Correlation Lab” qui utilise une approche similaire pour analyser les corrélations entre actifs de différentes classes.from itertools import combinations\n\n\ndef top_k_correlations(\n    assets: list[Asset],\n    k: int = 20,\n    use_absolute: bool = False\n) -> list[tuple[str, str, float]]:\n    \"\"\"\n    Extrait les K paires les plus corrélées d'une liste d'actifs.\n    \n    Cette fonction calcule la corrélation de Pearson entre toutes les\n    paires possibles d'actifs et retourne les K paires avec les plus\n    fortes corrélations.\n    \n    Args:\n        assets: Liste d'objets Asset\n        k: Nombre de paires à retourner (défaut: 20)\n        use_absolute: Si True, trie par |corrélation| pour capturer\n                      aussi les fortes corrélations négatives\n    \n    Returns:\n        Liste de tuples (ticker_1, ticker_2, corrélation) triée\n        par corrélation décroissante\n    \n    Complexity:\n        O(n²) où n = nombre d'actifs (toutes les paires sont calculées)\n    \n    Example:\n        >>> pairs = top_k_correlations(assets, k=5)\n        >>> pairs[0]\n        ('AAPL', 'MSFT', 0.85)\n    \n    Note:\n        Cette implémentation sera optimisée en Session 3 avec\n        des opérations matricielles vectorisées.\n    \"\"\"\n    correlations = []\n    \n    # itertools.combinations génère toutes les paires uniques\n    # évitant les doublons (A,B) et (B,A) et les auto-corrélations (A,A)\n    for asset_1, asset_2 in combinations(assets, 2):\n        # Calculer la corrélation\n        # Votre code ici...\n        pass\n    \n    # Trier par corrélation (ou valeur absolue) et retourner les k premières\n    # Votre code ici...\n    pass","type":"content","url":"/session2#contexte-en-finance-quantitative-1","position":65},{"hierarchy":{"lvl1":"Session 2 : Composition de Classes et Chargement de Données","lvl3":"Exercice 3 : Construction d’une matrice de corrélation (30 min)","lvl2":"Partie 2 : Exercices Pratiques"},"type":"lvl3","url":"/session2#exercice-3-construction-dune-matrice-de-corr-lation-30-min","position":66},{"hierarchy":{"lvl1":"Session 2 : Composition de Classes et Chargement de Données","lvl3":"Exercice 3 : Construction d’une matrice de corrélation (30 min)","lvl2":"Partie 2 : Exercices Pratiques"},"content":"Objectif : Créer une fonction qui construit une matrice de corrélation complète.","type":"content","url":"/session2#exercice-3-construction-dune-matrice-de-corr-lation-30-min","position":67},{"hierarchy":{"lvl1":"Session 2 : Composition de Classes et Chargement de Données","lvl4":"Contexte théorique","lvl3":"Exercice 3 : Construction d’une matrice de corrélation (30 min)","lvl2":"Partie 2 : Exercices Pratiques"},"type":"lvl4","url":"/session2#contexte-th-orique","position":68},{"hierarchy":{"lvl1":"Session 2 : Composition de Classes et Chargement de Données","lvl4":"Contexte théorique","lvl3":"Exercice 3 : Construction d’une matrice de corrélation (30 min)","lvl2":"Partie 2 : Exercices Pratiques"},"content":"La matrice de corrélation est une composante essentielle de l’analyse de portefeuille. D’après The Elements of Quantitative Investing (Paleologo) :\n\n“La variance du portefeuille (risque) dépend à la fois des volatilités individuelles ET des corrélations. La matrice de covariance capture la façon dont les actifs évoluent ensemble.”\n\nEt d’après Portfolio Optimization (Palomar, 2025) :\n\n“Les deux composantes principales de la conception de portefeuille sont la modélisation des données et l’optimisation du portefeuille. [...] Le but principal du bloc de modélisation est de caractériser la distribution statistique des rendements futurs, principalement en termes de moments de premier et second ordre (μ et Σ).”\n\nPropriétés de la matrice de corrélation :\n\nSymétrique : corr(A,B) = corr(B,A)\n\nDiagonale = 1 : corr(A,A) = 1 pour tout actif A\n\nValeurs dans [-1, 1] : par définition de la corrélation de Pearson\n\nSemi-définie positive : toute combinaison linéaire a une variance ≥ 0import pandas as pd\nimport numpy as np\nfrom itertools import combinations\n\n\ndef build_correlation_matrix(assets: list[Asset]) -> pd.DataFrame:\n    \"\"\"\n    Construit une matrice de corrélation pour tous les actifs.\n    \n    La matrice est symétrique : corr(A,B) = corr(B,A)\n    La diagonale vaut 1 : corr(A,A) = 1\n    \n    Args:\n        assets: Liste d'objets Asset\n    \n    Returns:\n        DataFrame symétrique avec tickers en index et colonnes\n    \n    Example:\n        >>> matrix = build_correlation_matrix([apple, msft, google])\n        >>> matrix.loc['AAPL', 'MSFT']\n        0.85\n    \"\"\"\n    tickers = [a.ticker for a in assets]\n    n = len(tickers)\n    \n    # Initialiser la matrice avec NaN\n    matrix = np.full((n, n), np.nan)\n    \n    # Remplir la diagonale avec 1.0 (auto-corrélation)\n    np.fill_diagonal(matrix, 1.0)\n    \n    # Créer un mapping ticker -> index pour un accès rapide O(1)\n    ticker_to_idx = {t: i for i, t in enumerate(tickers)}\n    \n    # Remplir le triangle supérieur et inférieur (symétrie)\n    # Votre code ici...\n    \n    return pd.DataFrame(matrix, index=tickers, columns=tickers)\n\n\ndef extract_upper_triangle(corr_matrix: pd.DataFrame) -> pd.DataFrame:\n    \"\"\"\n    Extrait les paires uniques du triangle supérieur de la matrice.\n    \n    Utile pour éviter les doublons (AAPL-MSFT et MSFT-AAPL) et\n    exclure la diagonale (auto-corrélations).\n    \n    Cette méthode est similaire à celle utilisée dans le projet\n    \"Global Multi-Asset Correlation Lab\".\n    \n    Args:\n        corr_matrix: Matrice de corrélation (DataFrame carré)\n    \n    Returns:\n        DataFrame avec colonnes ['asset_1', 'asset_2', 'correlation']\n        trié par corrélation décroissante\n    \"\"\"\n    # Créer un masque pour le triangle supérieur (excluant la diagonale k=1)\n    mask = np.triu(np.ones(corr_matrix.shape, dtype=bool), k=1)\n    \n    # Votre code ici...\n    pass","type":"content","url":"/session2#contexte-th-orique","position":69},{"hierarchy":{"lvl1":"Session 2 : Composition de Classes et Chargement de Données","lvl3":"Exercice 4 : Statistiques de l’univers (25 min)","lvl2":"Partie 2 : Exercices Pratiques"},"type":"lvl3","url":"/session2#exercice-4-statistiques-de-lunivers-25-min","position":70},{"hierarchy":{"lvl1":"Session 2 : Composition de Classes et Chargement de Données","lvl3":"Exercice 4 : Statistiques de l’univers (25 min)","lvl2":"Partie 2 : Exercices Pratiques"},"content":"Objectif : Ajouter une méthode summary() à la classe Universe.def summary(self) -> pd.DataFrame:\n    \"\"\"\n    Génère un résumé statistique de tous les actifs de l'univers.\n    \n    Returns:\n        DataFrame avec une ligne par actif et les colonnes:\n        - ticker\n        - sector\n        - current_price\n        - total_return\n        - volatility\n        - sharpe_ratio\n        - max_drawdown\n    \"\"\"\n    # Votre code ici...\n    pass","type":"content","url":"/session2#exercice-4-statistiques-de-lunivers-25-min","position":71},{"hierarchy":{"lvl1":"Session 2 : Composition de Classes et Chargement de Données","lvl2":"Solutions"},"type":"lvl2","url":"/session2#solutions","position":72},{"hierarchy":{"lvl1":"Session 2 : Composition de Classes et Chargement de Données","lvl2":"Solutions"},"content":"","type":"content","url":"/session2#solutions","position":73},{"hierarchy":{"lvl1":"Session 2 : Composition de Classes et Chargement de Données","lvl3":"Solution - Exercice 1","lvl2":"Solutions"},"type":"lvl3","url":"/session2#solution-exercice-1","position":74},{"hierarchy":{"lvl1":"Session 2 : Composition de Classes et Chargement de Données","lvl3":"Solution - Exercice 1","lvl2":"Solutions"},"content":"class Universe:\n    def __init__(self, assets: list[Asset] | None = None) -> None:\n        self._assets: dict[str, Asset] = {}\n        if assets:\n            for asset in assets:\n                self.add(asset)\n    \n    def add(self, asset: Asset) -> None:\n        self._assets[asset.ticker] = asset\n    \n    def get(self, ticker: str) -> Asset | None:\n        return self._assets.get(ticker)\n    \n    def remove(self, ticker: str) -> Asset | None:\n        return self._assets.pop(ticker, None)\n    \n    def __len__(self) -> int:\n        return len(self._assets)\n    \n    def __iter__(self) -> Iterator[Asset]:\n        return iter(self._assets.values())\n    \n    def __contains__(self, ticker: str) -> bool:\n        return ticker in self._assets\n    \n    def __repr__(self) -> str:\n        return f\"Universe({len(self)} assets: {self.tickers})\"\n    \n    @property\n    def tickers(self) -> list[str]:\n        return list(self._assets.keys())\n    \n    def filter_by_sector(self, sector: str) -> list[Asset]:\n        return [a for a in self._assets.values() if a.sector == sector]","type":"content","url":"/session2#solution-exercice-1","position":75},{"hierarchy":{"lvl1":"Session 2 : Composition de Classes et Chargement de Données","lvl3":"Solution - Exercice 2","lvl2":"Solutions"},"type":"lvl3","url":"/session2#solution-exercice-2","position":76},{"hierarchy":{"lvl1":"Session 2 : Composition de Classes et Chargement de Données","lvl3":"Solution - Exercice 2","lvl2":"Solutions"},"content":"from itertools import combinations\n\ndef top_k_correlations(\n    assets: list[Asset],\n    k: int = 20,\n    use_absolute: bool = False\n) -> list[tuple[str, str, float]]:\n    \"\"\"\n    Extrait les K paires les plus corrélées.\n    \n    Algorithme similaire au projet \"Global Multi-Asset Correlation Lab\"\n    mais adapté pour travailler avec des objets Asset plutôt qu'un DataFrame.\n    \"\"\"\n    correlations = []\n    \n    # Générer toutes les paires uniques avec combinations\n    for asset_1, asset_2 in combinations(assets, 2):\n        try:\n            corr = asset_1.correlation_with(asset_2)\n            correlations.append((asset_1.ticker, asset_2.ticker, corr))\n        except ValueError:\n            # Ignorer les paires avec données insuffisantes\n            continue\n    \n    # Fonction de tri : valeur absolue ou valeur brute\n    if use_absolute:\n        key_func = lambda x: abs(x[2])\n    else:\n        key_func = lambda x: x[2]\n    \n    # Trier par corrélation décroissante et retourner les k premières\n    return sorted(correlations, key=key_func, reverse=True)[:k]\n\nComparaison avec le Global Multi-Asset Correlation Lab :\n\nLe projet de référence utilise une approche matricielle :# Version matricielle (Correlation Lab)\ndef top_k_correlations(corr: pd.DataFrame, k: int=20, use_abs: bool=False):\n    m = corr.copy()\n    np.fill_diagonal(m.values, np.nan)\n    upper = m.where(np.triu(np.ones(m.shape), 1).astype(bool))\n    df = upper.stack().reset_index()\n    df.columns = [\"col_1\", \"col_2\", \"correlation\"]\n    key = df[\"correlation\"].abs() if use_abs else df[\"correlation\"]\n    return df.assign(_rk=key).sort_values(\"_rk\", ascending=False).head(k)\n\nNotre version avec boucles est pédagogiquement plus claire, mais sera optimisée en Session 3 avec une approche similaire à la version matricielle.","type":"content","url":"/session2#solution-exercice-2","position":77},{"hierarchy":{"lvl1":"Session 2 : Composition de Classes et Chargement de Données","lvl3":"Solution - Exercice 3","lvl2":"Solutions"},"type":"lvl3","url":"/session2#solution-exercice-3","position":78},{"hierarchy":{"lvl1":"Session 2 : Composition de Classes et Chargement de Données","lvl3":"Solution - Exercice 3","lvl2":"Solutions"},"content":"def build_correlation_matrix(assets: list[Asset]) -> pd.DataFrame:\n    \"\"\"Construit une matrice de corrélation pour tous les actifs.\"\"\"\n    tickers = [a.ticker for a in assets]\n    n = len(tickers)\n    \n    matrix = np.full((n, n), np.nan)\n    np.fill_diagonal(matrix, 1.0)\n    \n    ticker_to_idx = {t: i for i, t in enumerate(tickers)}\n    \n    for a1, a2 in combinations(assets, 2):\n        try:\n            corr = a1.correlation_with(a2)\n            i, j = ticker_to_idx[a1.ticker], ticker_to_idx[a2.ticker]\n            matrix[i, j] = corr\n            matrix[j, i] = corr  # Symétrie\n        except ValueError:\n            continue\n    \n    return pd.DataFrame(matrix, index=tickers, columns=tickers)\n\n\ndef extract_upper_triangle(corr_matrix: pd.DataFrame) -> pd.DataFrame:\n    \"\"\"\n    Extrait les paires uniques du triangle supérieur.\n    \n    Méthode identique à celle du Global Multi-Asset Correlation Lab.\n    \"\"\"\n    # Masque pour le triangle supérieur (k=1 exclut la diagonale)\n    mask = np.triu(np.ones(corr_matrix.shape, dtype=bool), k=1)\n    \n    # Appliquer le masque et convertir en format long\n    upper = corr_matrix.where(mask)\n    pairs = upper.stack().reset_index()\n    pairs.columns = ['asset_1', 'asset_2', 'correlation']\n    \n    # Trier par corrélation décroissante\n    return pairs.sort_values('correlation', ascending=False).reset_index(drop=True)","type":"content","url":"/session2#solution-exercice-3","position":79},{"hierarchy":{"lvl1":"Session 2 : Composition de Classes et Chargement de Données","lvl3":"Solution - Exercice 4","lvl2":"Solutions"},"type":"lvl3","url":"/session2#solution-exercice-4","position":80},{"hierarchy":{"lvl1":"Session 2 : Composition de Classes et Chargement de Données","lvl3":"Solution - Exercice 4","lvl2":"Solutions"},"content":"def summary(self) -> pd.DataFrame:\n    \"\"\"Génère un résumé statistique de l'univers.\"\"\"\n    data = []\n    \n    for asset in self._assets.values():\n        data.append({\n            'ticker': asset.ticker,\n            'sector': asset.sector,\n            'current_price': asset.current_price,\n            'total_return': asset.total_return,\n            'volatility': asset.volatility,\n            'sharpe_ratio': asset.sharpe_ratio,\n            'max_drawdown': asset.max_drawdown\n        })\n    \n    df = pd.DataFrame(data)\n    \n    # Trier par rendement total décroissant\n    return df.sort_values('total_return', ascending=False).reset_index(drop=True)","type":"content","url":"/session2#solution-exercice-4","position":81},{"hierarchy":{"lvl1":"Session 2 : Composition de Classes et Chargement de Données","lvl2":"Résumé de la Session 2"},"type":"lvl2","url":"/session2#r-sum-de-la-session-2","position":82},{"hierarchy":{"lvl1":"Session 2 : Composition de Classes et Chargement de Données","lvl2":"Résumé de la Session 2"},"content":"","type":"content","url":"/session2#r-sum-de-la-session-2","position":83},{"hierarchy":{"lvl1":"Session 2 : Composition de Classes et Chargement de Données","lvl3":"Concepts Python appris","lvl2":"Résumé de la Session 2"},"type":"lvl3","url":"/session2#concepts-python-appris","position":84},{"hierarchy":{"lvl1":"Session 2 : Composition de Classes et Chargement de Données","lvl3":"Concepts Python appris","lvl2":"Résumé de la Session 2"},"content":"Concept\n\nApplication\n\nComposition\n\nAsset POSSÈDE une PriceSeries\n\nAgrégation\n\nUniverse CONTIENT des Asset\n\nDécorateur @property\n\nAttributs calculés en lecture seule\n\nDécorateurs personnalisés\n\nChronométrage, logging\n\nListes\n\nCollections ordonnées et mutables\n\nDictionnaires\n\nMapping clé-valeur O(1)\n\nEnsembles\n\nCollections uniques, opérations ensemblistes\n\nCompréhensions\n\nCréation concise de collections\n\nExpressions génératrices\n\nÉvaluation paresseuse\n\nSystème de cache\n\nPersistance et optimisation des appels API","type":"content","url":"/session2#concepts-python-appris","position":85},{"hierarchy":{"lvl1":"Session 2 : Composition de Classes et Chargement de Données","lvl3":"Concepts de finance quantitative","lvl2":"Résumé de la Session 2"},"type":"lvl3","url":"/session2#concepts-de-finance-quantitative","position":86},{"hierarchy":{"lvl1":"Session 2 : Composition de Classes et Chargement de Données","lvl3":"Concepts de finance quantitative","lvl2":"Résumé de la Session 2"},"content":"Concept\n\nDescription\n\nRéférence\n\nCorrélation de Pearson\n\nMesure de relation linéaire entre actifs\n\nPortfolio Optimization Ch. 2\n\nMatrice de corrélation\n\nVue d’ensemble des relations dans un univers\n\nElements of QI Ch. 8\n\nTop-K corrélations\n\nIdentification des paires les plus liées\n\nCorrelation Lab\n\nStructure transversale\n\nModélisation conjointe des actifs\n\nPortfolio Optimization §2.5","type":"content","url":"/session2#concepts-de-finance-quantitative","position":87},{"hierarchy":{"lvl1":"Session 2 : Composition de Classes et Chargement de Données","lvl3":"Continuité pédagogique","lvl2":"Résumé de la Session 2"},"type":"lvl3","url":"/session2#continuit-p-dagogique","position":88},{"hierarchy":{"lvl1":"Session 2 : Composition de Classes et Chargement de Données","lvl3":"Continuité pédagogique","lvl2":"Résumé de la Session 2"},"content":"Cette session pose les bases qui seront étendues dans les sessions suivantes :\n\nSession 2 (Boucles)\n\nSession 3 (Vectorisé)\n\ntop_k_correlations(assets)\n\nuniverse.top_correlations()\n\nbuild_correlation_matrix(assets)\n\nuniverse.correlation_matrix()\n\nBoucles O(n²)\n\nOpérations matricielles NumPy","type":"content","url":"/session2#continuit-p-dagogique","position":89},{"hierarchy":{"lvl1":"Session 2 : Composition de Classes et Chargement de Données","lvl2":"Travail à faire"},"type":"lvl2","url":"/session2#travail-faire","position":90},{"hierarchy":{"lvl1":"Session 2 : Composition de Classes et Chargement de Données","lvl2":"Travail à faire"},"content":"Étendre Universe : Ajouter une méthode covariance_matrix() qui retourne la matrice de covariance\n\nExpiration du cache : Modifier DataLoader pour ignorer les fichiers cache de plus de N jours\n\nLecture préparatoire : Lire la documentation de NumPy et les chapitres sur les opérations matricielles","type":"content","url":"/session2#travail-faire","position":91},{"hierarchy":{"lvl1":"Session 2 : Composition de Classes et Chargement de Données","lvl2":"Références"},"type":"lvl2","url":"/session2#r-f-rences","position":92},{"hierarchy":{"lvl1":"Session 2 : Composition de Classes et Chargement de Données","lvl2":"Références"},"content":"Lott, S. & Phillips, D. (2021). Python Object-Oriented Programming, 4th Edition. Packt.\n\nRamalho, L. (2022). Fluent Python, 2nd Edition. O’Reilly.\n\nPalomar, D. P. (2025). Portfolio Optimization: Theory and Application. Cambridge University Press.\n\nPaleologo, G. (2024). The Elements of Quantitative Investing. Chapman & Hall/CRC.\n\nDocumentation yfinance : \n\nhttps://​ranaroussi​.github​.io​/yfinance/\n\nDiederich, J. (2012). “Stop Writing Classes” - PyCon 2012\n\nGlobal Multi-Asset Correlation Lab - Complexity Explorer Project","type":"content","url":"/session2#r-f-rences","position":93}]}